PREREQUISITES AND ASSUMPTIONS

Assumptions:	
1.	You know how to write code in Python 3
2.	You have a basic knowledge of HTML
3.	You are willing to learn some Django
4.	You are willing to learn some JavaScript

Prerequisites:
1.	Firefox web browser
2.	Git version control system.
3.	A virtualenv with Python 3, Django 1.11 and Selenium 3 in it.
4.	Geckodriver

PART I: THE BASICS OF TDD AND DJANGO

CHAPTER 1: GETTING DJANGO SET UP USING A FUNCTIONAL TEST

A.	Functional test written which checks to make sure “Django” is in the web-page title.
	
	Running this test fails. We don’t yet have a server up and running.
	
B.	New project “superlists” created using django-admin.py
C.	Server started using manage.py

D.	Functional test run again.

	Running test passes.

E. 	Git repository started.
	Files that we don’t want tracked are added to .gitignore
F.	COMMIT 1: “First Commit: First FT and Basic Django config.

CHAPTER 2: EXTENDING OUR FUNCTIONAL TEST USING THE unittest  MODULE

Project revealed: A To-Do List

A.	Functional Test redesigned: User story created. Test now checks that the text “To-Do” appears 
	in the browser title.

B.	Test run and fails: The Assertion fails. This is cryptic. Furthermore, the process annoyingly 
	leaves an open browser window hanging around.

C.	Functional Test rewritten using the python module unittest. Groups of tests are classes.
	Individual tests are methods within the classes that begin with the word “test”. The name
	of each test should be highly descriptive. Each class may have an unlimited number of tests.
	The classes may include other methods besides tests. Two useful ones are
	setUp

	and

	tearDown.

	These designate the actions that the test class will take at the beginning and at the end, 
	regardless of whether or not there is an error.

	Some useful unittest functions:

	assertIn(object, location)
	A special assertion that is much more descriptive that the default assert.

	fail(message)
	A function that always fails. Useful as a testing “bookmark”.

D.	Functional test run again. Fails the assertIn test, giving a message that “To-Do” does not appear
	in the browser title.

E.	COMMIT 2: “First FT specced out in comments, and now uses unittest.”

CHAPTER 3: TESTING A SIMPLE HOME PAGE WITH UNIT TESTS

A.	First app created for our project, called “lists.” Created with manage.py startapp

B.      First (silly) unittest written.

C.      COMMIT 3: "Add app for lists, with deliberately failing unit test."

D.      Rewrote the unittests. class HomePageTest. def test_root_url_resolved_to_home_page_view

E.      Test failed because the home_page import from lists.views has not been written.

F.      home_page declared in views as equal to None

G.      Test failed because there is no URL associated with our view.

H.      Went to superlists/urls.py and got rid of admin import,
        replaced it with lists.views import and altered the first urlpattern to send to the homepage on empty text.

I.      Test failed because home_page as defined is not callable, or a list/tuple.

J.      In views, redefined home_page as a function that does nothing.

K.      Unittest passed.

L.      COMMIT 4: "First unit test and url mapping, dummy view."

M.      /lists/tests: added import to django.http.HttpRequest. Added a new test method to the class,
        test_home_page_returns_correct_html. Wrote code to make home_page the response based on the request,
        to decode the bytes into utf8 and call this html, and assertions that this begins with the html tag,
        contains the title To-Do lists and ends with the close html tag.

N.      Unittest fails because it is sending an argument to home_page, which currently has no parameters.

O.      Changed home_page view to take a single parameter called "request".

P.      Unittest fails because the test is expecting the return value from home_page to have an attribute called
        "content." But the home_page view returns None.

Q.      in views, added an import to django.http.HttpResponse. Rewrote the home_page function so that it returns
        HttpResponse.

R.      Unit test fails because the decoded response does not begin with the html tag.

S.      Added html tag to views.

T.      Unit test fails because it does not contain the title.

U.      Added title to views.

V.      Unit test fails because it doesn't end with html close tag.

W.      html close tag added to views.

X.      Unit test passes.

Y.      Functional test fails at our bookmark failure only.

Z.      COMMIT 5: "Basic view now returns minimal HTML"

CHAPTER 4. WHAT ARE WE DOING WITH ALL THESE TESTS? (AND REFACTORING)

A.      Ran the Functional Test and got the same error at our bookmark.

B.      Fleshed out the Functional Test much more. Now imports Keys from Selenium.
        Locates the header text and tests to see if
        To-Do is in the text. Tests to make sure the inputbox contains the text 'Enter a to-do item'.
        Sends the key 'Buy peacock feathers'. Enters them. Sleeps for 1 second. Finds the rows of the
        table and verifies that the text '1: Buy peacock featers' appears somewhere in the table.
        Moved the failure bookmark here.
        We used a few new Selenium functions: find_element_by_tag_name, find_element_by_id, get_attribute
        send_keys, Keys.ENTER

C.      Functional Test failed because element 'h1' is not on the page.

D.      COMMIT 6: "Functional test now checks we can add a to-do item"

E.      Since the unit testing we currently have tests constants (not really what unit tests are for)
        we are going to relegate the content of views to files written in HTML. This is refactoring.
        We are attempting to improve the code while maintaining the same functionality. This requires
        tests. The first thing we do is re-run our current unit tests. These passed, as expected.

F.      Created the directory lists/templates. Created a HTML file in lists/templates called home.html. It contains exactly the same
        content that the previous "hard-wired" view does.

G.      Changed the views file. We got rid of the hard-coded stuff. We got rid of the
        htmlrequest import. Now the home_page function returns the render(request, 'home.html')

H.      Unit test fails because home.html is not recognized as a template.

I.      We realize that having an html file in the templates file is not enough to use it in rendering a view.
        We need to register the lists app in the superlists/settings file. This is put in the INSTALLED_APPS.

J.      Unit test fails because the page does not end in '</html>/'. This is because converting the view to
        a template resulted in an inavertant addition of a newline.

K.      Since it does not matter if there is whitespace at the end of the page, we change the test to
        check on the presence of the stripped html close tag.

L.      Unit test passes.

M.      Change the unit test so that it no longer checks for specific test. Instead, it checks to make
        sure the correct template is utilized.

N.      Unit Test passes.

O.      Since test didn't fail, we create a deliberately failing condition to check it: we give it the wrong
        name for the template. And it fails as expected. We replace the correct template.

P.      Removed the test_root_url_resolves test. Removed all assertions except the assertTemplateUsed.
        django's client.get takes care of everything else.

Q.      did a git add . because we now have a new html file to keep track of.

R.      COMMIT 7: "Refactor home page view to use a template."

S.      Since the functional test will still fail...the page still does not include h1...we now can change
        our template to have this. And since we have a template, we do not need to create new unit tests
        to test the functionality of the addition.

T.      Functional tests fail because the element with id "id_new_item" cannot be found in the page.

U.      Changed the template to include an input with id tag "id_new_item"

V.      Functional tests fail because "Enter a to-do item" is not found in the page.

W.      We add our placeholder variable to the home page.

X.      Functional tests fail because the element with id "id_list_table" is not found on the page.

Y.      We put an empty table in home with the correct id.

Z.      Functional tests fail because "1: Buy peacock feathers" is not found in table. Also, the error
        message is cryptic on behalf of the assertTrue function. We add an explicit error message to
        this function.

AA.     Functional tests fail again for the same reason. But now we have a more understandable error
        message.

AB.     COMMIT 8: "Front page HTML now generated from a template."

CHAPTER 5. SAVING USER INPUT: TESTING THE DATABASE

A.      We need to be able to save user input. Our first attempts at this will involve simple
        POST requests. We need to update our home.html template. The <input> element is given a name
        and it is wrapped in a <form> tag with method = "POST"

B.      Functional test fails for an unexpected reason. Error message is cryptic. We decide to extend
        the already present "sleep" function in the functional test to allow us a good look at the webpage.

C.      It turns out, that the Functional test fails because Django is expecting a CSRF token. A CSRF =
        Cross-Site Forgery Request = a type of attack that relies on hijacking a user's POST requests
        to access aspects of a site that the hacker would not normally have access to. Django's solution
        to this problem is to generate, and check for the presence of, a random key in the document.
        The hacker will not have this key and will not be able to hijack the post request. To make
        get Django to generate this tag, we will insert {% csrf_token %} into our form on the template.

D.      Functional test fails because the test item did not make it into the table. The problem is that
        the views file is not set up to deal with a POST request. It simply directs everything to the
        home page, which does us no good.

E.      We replace the original sleep duration in the functional test. Then we add a new test in the unit
        tests. test_can_save_a_POST_request.

F.      The Unit test fails as expected. We need to get the views to recognize a POST request.

G.      The simplest way to get the unit test to pass is to rewrite the views to return a POST request
        when an item is sent to the list.

H.      The Unit test passes. However, we are not accomplishing what we wish to accomplish. The
        item is not being added to list database.

I.      We change our home template. We add the Python variable new_item_text to the a row of the table,
        and enclose this in double braces, which will render the variable as a string. Then we adjust the
        unit test to test whether or not the home template is still being used to render the POST request.

J.      The unit test fails, as expected.

K.      We simplify our home page view to allow for a post request for a new item.

L.      The unit test fails for an unexpected reason: in redesigning our views, we accidentally got rid
        of the POST request.

M.      We alter the view so that it uses request.POST.get. It takes the variable name, and we also
        give it a default value, the empty string.


N.      The unit test passes.

O.      The functional tests fails. The new to-do item is still not appearing in the table. This is
        an unexpected error.

P.      We improve the error message in the assertion function that shows us the contents of the
        table. We used the f string syntax, introduced in Python 3.6

Q.      Functional test fails again, as expected. This time we see that the item made it into the table,
        but that it contains no "1", which we wanted the table entry to contain.

R.      We realize that our assertion is overly complex. We were trying to be too clever by using
        the Python "all" built-in function. We change the assertion to make it much simpler, and
        function better.

S.      The Functional test fails as expected. This time, we get a clear error message as a side-effect
        of our simpler assertion.

T.      The fastest way to fix this error is simply to write a 1 in the template. We do this.

U.      The Functional test fails at the bookmark. All earlier tests pass. But of course, this
        cannot be the permanent solution...because we don't want every list item to contain the
        number 1.

V.      We complete more of our Functional Test. Now, in addition, it will check a second item, and
        see if both items are in the database. In so doing, it will check that the second item
        begins with a "2".

W.      Functional test fails because the first entry was not retained in the list.

X.      We pause because, in addition to the fail, we have a "bad code smell." The code is getting
        repetitive. We need to refactor to remove duplication before we fix the problem. Before doing a
        refactor, we always make a commit.

Y.      COMMIT 9: "To-Do list now can handle user input."

Z.      We add a hepler method to the functional test (not beginning with "test"): check_for_row_in_list_table.
        Then we remove the two sections of code that did this same check and replace them with calls to
        the helper method.

AA.     The functional test fails, as expected, and in the same way. This is good news. It means our
        refactoring did not change the way the site or the tests work.

AB.     COMMIT 10: Functional test refactoring: Checking for text within rows is now accomplished by a helper function.

AC.     To get the site to retain items, we must put them in a database. Working with databases in object-oriented
        languages is usually accomplished through a ORM: Object-Relational Manager.
        Tables are classes. Columns are attributes. Rows are instances of the class. Django has a very good ORM,
        and we will use it. We alter tests.py. First we add an import: from lists.models import Item. Then we write
        a new class: ItemModelTest. In this new class, we add a new test method: test_saving_and_retrieving_items.

        New Django functions: .save() saves an item with its attributes to a database.
                              .objects() allows us to query the database.
                              .all() is the simplest query: it retrieves all items for the table.
                              The items are returned in a list-like object called a QuerySet
                              .count() returns the count of entries in the QuerySet

AD.    Unit test fails because it cannot find the import lists.models.Item.

AE.    We create a class in models called Item. It does nothing.

AF.    Unit test fails because Item has no attribute "save".

AG.    We change Item so that it inherits from Django's Model class.

AH.    Unit test fails because it can't find a table called "lists_item". Although we've defined
       a table in our template, we have no actual table.

AI.    We rely on a separate Django system
       called "migrations" which moves our information over to an actual table. We need
       to make migrations. We do this the first time with running manage.py makemigrations

AJ.    Unit test fails because Item has no attribute "text".

AK.    The models.Models object maps tables to a database. It automatically generates an id
       attribute for each item, but must be instructed how to deal with the information we
       provide. We change our Item class and add text = models.TextField(). Django has
       many other field types.

AL.    Unit test fails because it does not recognize the "lists_item.text" as a column name.

AM.    Since we added a column, we need to do another migration. We try the same method we used before.

AN.    This attempt fails. We need to either give a universal default, or set one up in models.py.

AO.    We alter the definition of "text" in the Item class of models.py so that it carries the
       argument "default=''", the default is the empty string.

AP.    We attempt to run makemigrations again and it works.

AQ.    Unit tests pass.

AR.    We add "lists" to our git.

AS.    COMMIT 11: "Model for list Items and associated migration"

AT.    We expand the unit tests. Now test_can_save_a_POST_request checks to see if the item was added to
       the database, and just rendered as a RESPONSE. While we're at it, we notice that this test is
       getting long. It is issuing a "code smell." We make a to-do list of our own. And the sole
       item on the list is POST request test too long?

AU.    Unit test fails because there are no items in the database.

AV.    We adjust our view. We import lists.models. We redo the home_page view to accept and save a POST request
       wrapped in an Item. Our naive solution saves an empty item to the database every time we request the
       home page. We add this problem to our to-do list.

AW.    Unit tests passed.

AX.    We refactor a little in the views.

AY.    Now we have a to-do list with four items.
       1.  Don't save blank lines for every request.
       2.  Code smell: POST test is too long?
       3.  Display multiple items in the table.
       4.  Support more than one list!

AZ.    Item no. 1: Don't save blank lines for every request. We create a new test method in our HomePageTest
       to make sure simple redirects no not POST anything to the table.

BA.    Unit test fails as expected because there was an empty entry posted on simple redirect.

BB.    We tweek the views to fix this problem.

BC.    Unit test passes.

BD.    We need to refactor. The new_item_text = '' is lame. And, following the dictum of "always
       redirect after a POST", we alter our unit tests again. We assert that the response status
       code = 302 and we assert that the location of the response is home.

BE.    Unit test fails because status code is 200. 302 is the status code for redirect. 200
       is the status code for "user has requested documents and they were successfully delivered."

BF.    We tidy up our view. We add an import django.shortcuts.redirect. Then we simply return
       a request of home.html if this is not a post.

BG.    Unit test passes.

BH.    2. Code smell: POST test too long?
       Now, we should test only one thing at a time. In other words, each unit test method should
       contain only one assertion. So we refactor the unit tests to obey this dictum.

BI.    Unit test passes, as expected. Now we have five unit test methods instead of four, but
       these are testing the same things as before.

BJ.    3. Display multiple items in the table. We create a new unit test method
       test_displays_all_list_items

BK.    Unit test fails as expected. The first test item does not appear in the response content.

BL.    We alter the home.html template to allow the table to be iterated through. Then we change our
       home page view to pass the items to the template.

BM.    Unit test passes.

BN.    Functional Test fails for a cryptic reason. We decide to try a new debugging technique: we
       open up the browser at http://local-host:8000 and see what is going on. It turns out we
       didn't set up the database properly. Our unit tests worked because Django's TestCase
       creates a temporary database in which to store data. But the real one wasn't being
       created or utilized. Django has everything it needs to create the database. This is
       because 1. The database is indicated in settings (it is the default sqlite3 file
       which is generated automatically when we make an app) 2. We performed the
       manage.py migrations function. However, Django needs a direct order to go
       ahead and set up this database. The command is manage.py migrate. We refresh the
       webpage and see that the error page is gone.

BO.    The functional test fails because it is numbering every item with 1, as we
       hardcoded in a little while ago.

BP.    We add another Django feature forloop.counter, which should give us the numbering we desire.

BQ.    The functional test fails at the bookmark. All previous tests passed. However, there is
       a disturbing new development. Every time we run the test, the same two items get added
       anew to the database. So the database keeps getting bigger everytime we run the
       functional tests. We erase the data base, do another migrate to start the process over.
       And now it's time for another Commit.

BR.    COMMIT 12: "Redirect after POST, and show all items in template."

BS.    This is the current state of our to-do list:
       1. Clean up after functional test runs.
       2. Support more than one list!

CHAPTER 6: IMPROVING FUNCTIONAL TESTS: INSURING ISOLATION AND REMOVING VOODOO SLEEPS

A.      Before we improve the project, we have two orders of business. The first is the
        first item of the our to-do list: clean up after functional test runs.
        The other is a new concern. We have time.sleep() functions peppering our
        Functional tests. This is not ideal. So our to-do list is
        1. Clean up after functional tests.
        2. Remove time.sleep
        3. Support more than one list!

B.      To isolate our Functional tests we could write clean-up code in the file.
        However, we can also use a feature of Django: LiveServerTestCase.
        In preparation, we create a new folder called functional_tests. We put
        an empty __init__.py file in the folder. Then we move the functional_tests file
        to functional_tests/tests. The folder functional_tests will be a new app in
        our project. We do the moving with git mv. This way, git can keep track of
        the location of the file. Next, we alter functional_tests/tests to make use
        of LiveServerTestCase. To do so, we add an import django.test.LiveServerTestCase.
        We remove the import of unittest. We make the NewVisitorTest inherit from LiveServerTestCase.
        We change the browser page call in test_can_start_a_list_and_retrieve_it_later to
        self.live_server_url. And we remove the code at the bottom that makes the
        tests file workable as a runable file.
        

C.      The new way to run our functional tests is like this: manage.py test functional_tests
