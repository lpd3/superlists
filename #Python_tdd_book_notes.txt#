PREREQUISITES AND ASSUMPTIONS

Assumptions:	
1.	You know how to write code in Python 3
2.	You have a basic knowledge of HTML
3.	You are willing to learn some Django
4.	You are willing to learn some JavaScript

Prerequisites:
1.	Firefox web browser
2.	Git version control system.
3.	A virtualenv with Python 3, Django 1.11 and Selenium 3 in it.
4.	Geckodriver

PART I: THE BASICS OF TDD AND DJANGO

CHAPTER 1: GETTING DJANGO SET UP USING A FUNCTIONAL TEST

A.	Functional test written which checks to make sure “Django” is in the web-page title.
	
	Running this test fails. We don’t yet have a server up and running.
	
B.	New project “superlists” created using django-admin.py
C.	Server started using manage.py

D.	Functional test run again.

	Running test passes.

E. 	Git repository started.
	Files that we don’t want tracked are added to .gitignore
F.	COMMIT 1: “First Commit: First FT and Basic Django config.

CHAPTER 2: EXTENDING OUR FUNCTIONAL TEST USING THE unittest  MODULE

Project revealed: A To-Do List

A.	Functional Test redesigned: User story created. Test now checks that the text “To-Do” appears 
	in the browser title.

B.	Test run and fails: The Assertion fails. This is cryptic. Furthermore, the process annoyingly 
	leaves an open browser window hanging around.

C.	Functional Test rewritten using the python module unittest. Groups of tests are classes.
	Individual tests are methods within the classes that begin with the word “test”. The name
	of each test should be highly descriptive. Each class may have an unlimited number of tests.
	The classes may include other methods besides tests. Two useful ones are
	setUp

	and

	tearDown.

	These designate the actions that the test class will take at the beginning and at the end, 
	regardless of whether or not there is an error.

	Some useful unittest functions:

	assertIn(object, location)
	A special assertion that is much more descriptive that the default assert.

	fail(message)
	A function that always fails. Useful as a testing “bookmark”.

D.	Functional test run again. Fails the assertIn test, giving a message that “To-Do” does not appear
	in the browser title.

E.	COMMIT 2: “First FT specced out in comments, and now uses unittest.”

CHAPTER 3: TESTING A SIMPLE HOME PAGE WITH UNIT TESTS

A.	First app created for our project, called “lists.” Created with manage.py startapp

B.      First (silly) unittest written.

C.      COMMIT 3: "Add app for lists, with deliberately failing unit test."

D.      Rewrote the unittests. class HomePageTest. def test_root_url_resolved_to_home_page_view

E.      Test failed because the home_page import from lists.views has not been written.

F.      home_page declared in views as equal to None

G.      Test failed because there is no URL associated with our view.

H.      Went to superlists/urls.py and got rid of admin import,
        replaced it with lists.views import and altered the first urlpattern to send to the homepage on empty text.

I.      Test failed because home_page as defined is not callable, or a list/tuple.

J.      In views, redefined home_page as a function that does nothing.

K.      Unittest passed.

L.      COMMIT 4: "First unit test and url mapping, dummy view."

M.      /lists/tests: added import to django.http.HttpRequest. Added a new test method to the class,
        test_home_page_returns_correct_html. Wrote code to make home_page the response based on the request,
        to decode the bytes into utf8 and call this html, and assertions that this begins with the html tag,
        contains the title To-Do lists and ends with the close html tag.

N.      Unittest fails because it is sending an argument to home_page, which currently has no parameters.

O.      Changed home_page view to take a single parameter called "request".

P.      Unittest fails because the test is expecting the return value from home_page to have an attribute called
        "content." But the home_page view returns None.

Q.      in views, added an import to django.http.HttpResponse. Rewrote the home_page function so that it returns
        HttpResponse.

R.      Unit test fails because the decoded response does not begin with the html tag.

S.      Added html tag to views.

T.      Unit test fails because it does not contain the title.

U.      Added title to views.

V.      Unit test fails because it doesn't end with html close tag.

W.      html close tag added to views.

X.      Unit test passes.

Y.      Functional test fails at our bookmark failure only.

Z.      COMMIT 5: "Basic view now returns minimal HTML"

CHAPTER 4. WHAT ARE WE DOING WITH ALL THESE TESTS? (AND REFACTORING)

A.      Ran the Functional Test and got the same error at our bookmark.

B.      Fleshed out the Functional Test much more. Now imports Keys from Selenium.
        Locates the header text and tests to see if
        To-Do is in the text. Tests to make sure the inputbox contains the text 'Enter a to-do item'.
        Sends the key 'Buy peacock feathers'. Enters them. Sleeps for 1 second. Finds the rows of the
        table and verifies that the text '1: Buy peacock featers' appears somewhere in the table.
        Moved the failure bookmark here.
        We used a few new Selenium functions: find_element_by_tag_name, find_element_by_id, get_attribute
        send_keys, Keys.ENTER

C.      Functional Test failed because element 'h1' is not on the page.

D.      COMMIT 6: "Functional test now checks we can add a to-do item"

E.      Since the unit testing we currently have tests constants (not really what unit tests are for)
        we are going to relegate the content of views to files written in HTML. This is refactoring.
        We are attempting to improve the code while maintaining the same functionality. This requires
        tests. The first thing we do is re-run our current unit tests. These passed, as expected.

F.      Created the directory lists/templates. Created a HTML file in lists/templates called home.html. It contains exactly the same
        content that the previous "hard-wired" view does.

G.      Changed the views file. We got rid of the hard-coded stuff. We got rid of the
        htmlrequest import. Now the home_page function returns the render(request, 'home.html')

H.      Unit test fails because home.html is not recognized as a template.

I.      We realize that having an html file in the templates file is not enough to use it in rendering a view.
        We need to register the lists app in the superlists/settings file. This is put in the INSTALLED_APPS.

J.      Unit test fails because the page does not end in '</html>/'. This is because converting the view to
        a template resulted in an inavertant addition of a newline.

K.      Since it does not matter if there is whitespace at the end of the page, we change the test to
        check on the presence of the stripped html close tag.

L.      Unit test passes.

M.      Change the unit test so that it no longer checks for specific test. Instead, it checks to make
        sure the correct template is utilized.

N.      Unit Test passes.

O.      Since test didn't fail, we create a deliberately failing condition to check it: we give it the wrong
        name for the template. And it fails as expected. We replace the correct template.

P.      Removed the test_root_url_resolves test. Removed all assertions except the assertTemplateUsed.
        django's client.get takes care of everything else.

Q.      did a git add . because we now have a new html file to keep track of.

R.      COMMIT 7: "Refactor home page view to use a template."

S.      Since the functional test will still fail...the page still does not include h1...we now can change
        our template to have this. And since we have a template, we do not need to create new unit tests
        to test the functionality of the addition.

T.      Functional tests fail because the element with id "id_new_item" cannot be found in the page.

U.      Changed the template to include an input with id tag "id_new_item"

V.      Functional tests fail because "Enter a to-do item" is not found in the page.

W.      We add our placeholder variable to the home page.

X.      Functional tests fail because the element with id "id_list_table" is not found on the page.

Y.      We put an empty table in home with the correct id.

Z.      Functional tests fail because "1: Buy peacock feathers" is not found in table. Also, the error
        message is cryptic on behalf of the assertTrue function. We add an explicit error message to
        this function.

AA.     Functional tests fail again for the same reason. But now we have a more understandable error
        message.

AB.     COMMIT 8: "Front page HTML now generated from a template."

CHAPTER 5. SAVING USER INPUT: TESTING THE DATABASE

A.      We need to be able to save user input. Our first attempts at this will involve simple
        POST requests. We need to update our home.html template. The <input> element is given a name
        and it is wrapped in a <form> tag with method = "POST"

B.      Functional test fails for an unexpected reason. Error message is cryptic. We decide to extend
        the already present "sleep" function in the functional test to allow us a good look at the webpage.

C.      It turns out, that the Functional test fails because Django is expecting a CSRF token. A CSRF =
        Cross-Site Forgery Request = a type of attack that relies on hijacking a user's POST requests
        to access aspects of a site that the hacker would not normally have access to. Django's solution
        to this problem is to generate, and check for the presence of, a random key in the document.
        The hacker will not have this key and will not be able to hijack the post request. To make
        get Django to generate this tag, we will insert {% csrf_token %} into our form on the template.

D.      Functional test fails because the test item did not make it into the table. The problem is that
        the views file is not set up to deal with a POST request. It simply directs everything to the
        home page, which does us no good.

E.      We replace the original sleep duration in the functional test. Then we add a new test in the unit
        tests. test_can_save_a_POST_request.

F.      The Unit test fails as expected. We need to get the views to recognize a POST request.

G.      The simplest way to get the unit test to pass is to rewrite the views to return a POST request
        when an item is sent to the list.

H.      The Unit test passes. However, we are not accomplishing what we wish to accomplish. The
        item is not being added to list database.

I.      We change our home template. We add the Python variable new_item_text to the a row of the table,
        and enclose this in double braces, which will render the variable as a string. Then we adjust the
        unit test to test whether or not the home template is still being used to render the POST request.

J.      The unit test fails, as expected.

K.      We simplify our home page view to allow for a post request for a new item.

L.      The unit test fails for an unexpected reason: in redesigning our views, we accidentally got rid
        of the POST request.

M.      We alter the view so that it uses request.POST.get. It takes the variable name, and we also
        give it a default value, the empty string.


N.      The unit test passes.

O.      The functional tests fails. The new to-do item is still not appearing in the table. This is
        an unexpected error.

P.      We improve the error message in the assertion function that shows us the contents of the
        table. We used the f string syntax, introduced in Python 3.6

Q.      Functional test fails again, as expected. This time we see that the item made it into the table,
        but that it contains no "1", which we wanted the table entry to contain.

R.      We realize that our assertion is overly complex. We were trying to be too clever by using
        the Python "all" built-in function. We change the assertion to make it much simpler, and
        function better.

S.      The Functional test fails as expected. This time, we get a clear error message as a side-effect
        of our simpler assertion.

T.      The fastest way to fix this error is simply to write a 1 in the template. We do this.

U.      The Functional test fails at the bookmark. All earlier tests pass. But of course, this
        cannot be the permanent solution...because we don't want every list item to contain the
        number 1.

V.      We complete more of our Functional Test. Now, in addition, it will check a second item, and
        see if both items are in the database. In so doing, it will check that the second item
        begins with a "2".

W.      Functional test fails because the first entry was not retained in the list.

X.      We pause because, in addition to the fail, we have a "bad code smell." The code is getting
        repetitive. We need to refactor to remove duplication before we fix the problem. Before doing a
        refactor, we always make a commit.

Y.      COMMIT 9: "To-Do list now can handle user input."

Z.      We add a hepler method to the functional test (not beginning with "test"): check_for_row_in_list_table.
        Then we remove the two sections of code that did this same check and replace them with calls to
        the helper method.

AA.     The functional test fails, as expected, and in the same way. This is good news. It means our
        refactoring did not change the way the site or the tests work.

AB.     COMMIT 10: Functional test refactoring: Checking for text within rows is now accomplished by a helper function.

AC.     To get the site to retain items, we must put them in a database. Working with databases in object-oriented
        languages is usually accomplished through a ORM: Object-Relational Manager.
        Tables are classes. Columns are attributes. Rows are instances of the class. Django has a very good ORM,
        and we will use it. We alter tests.py. First we add an import: from lists.models import Item. Then we write
        a new class: ItemModelTest. In this new class, we add a new test method: test_saving_and_retrieving_items.

        New Django functions: .save() saves an item with its attributes to a database.
                              .objects() allows us to query the database.
                              .all() is the simplest query: it retrieves all items for the table.
                              The items are returned in a list-like object called a QuerySet
                              .count() returns the count of entries in the QuerySet

AD.    Unit test fails because it cannot find the import lists.models.Item.

AE.    We create a class in models called Item. It does nothing.

AF.    Unit test fails because Item has no attribute "save".

AG.    We change Item so that it inherits from Django's Model class.

AH.    Unit test fails because it can't find a table called "lists_item". Although we've defined
       a table in our template, we have no actual table.

AI.    We rely on a separate Django system
       called "migrations" which moves our information over to an actual table. We need
       to make migrations. We do this the first time with running manage.py makemigrations

AJ.    Unit test fails because Item has no attribute "text".

AK.    The models.Models object maps tables to a database. It automatically generates an id
       attribute for each item, but must be instructed how to deal with the information we
       provide. We change our Item class and add text = models.TextField(). Django has
       many other field types.

AL.    Unit test fails because it does not recognize the "lists_item.text" as a column name.

AM.    Since we added a column, we need to do another migration. We try the same method we used before.

AN.    This attempt fails. We need to either give a universal default, or set one up in models.py.

AO.    We alter the definition of "text" in the Item class of models.py so that it carries the
       argument "default=''", the default is the empty string.

AP.    We attempt to run makemigrations again and it works.

AQ.    Unit tests pass.

AR.    We add "lists" to our git.

AS.    COMMIT 11: "Model for list Items and associated migration"

AT.    We expand the unit tests. Now test_can_save_a_POST_request checks to see if the item was added to
       the database, and just rendered as a RESPONSE. While we're at it, we notice that this test is
       getting long. It is issuing a "code smell." We make a to-do list of our own. And the sole
       item on the list is POST request test too long?

AU.    Unit test fails because there are no items in the database.

AV.    We adjust our view. We import lists.models. We redo the home_page view to accept and save a POST request
       wrapped in an Item. Our naive solution saves an empty item to the database every time we request the
       home page. We add this problem to our to-do list.

AW.    Unit tests passed.

AX.    We refactor a little in the views.

AY.    Now we have a to-do list with four items.
       1.  Don't save blank lines for every request.
       2.  Code smell: POST test is too long?
       3.  Display multiple items in the table.
       4.  Support more than one list!

AZ.    Item no. 1: Don't save blank lines for every request. We create a new test method in our HomePageTest
       to make sure simple redirects no not POST anything to the table.

BA.    Unit test fails as expected because there was an empty entry posted on simple redirect.

BB.    We tweek the views to fix this problem.

BC.    Unit test passes.

BD.    We need to refactor. The new_item_text = '' is lame. And, following the dictum of "always
       redirect after a POST", we alter our unit tests again. We assert that the response status
       code = 302 and we assert that the location of the response is home.

BE.    Unit test fails because status code is 200. 302 is the status code for redirect. 200
       is the status code for "user has requested documents and they were successfully delivered."

BF.    We tidy up our view. We add an import django.shortcuts.redirect. Then we simply return
       a request of home.html if this is not a post.

BG.    Unit test passes.

BH.    2. Code smell: POST test too long?
       Now, we should test only one thing at a time. In other words, each unit test method should
       contain only one assertion. So we refactor the unit tests to obey this dictum.

BI.    Unit test passes, as expected. Now we have five unit test methods instead of four, but
       these are testing the same things as before.

BJ.    3. Display multiple items in the table. We create a new unit test method
       test_displays_all_list_items

BK.    Unit test fails as expected. The first test item does not appear in the response content.

BL.    We alter the home.html template to allow the table to be iterated through. Then we change our
       home page view to pass the items to the template.

BM.    Unit test passes.

BN.    Functional Test fails for a cryptic reason. We decide to try a new debugging technique: we
       open up the browser at http://local-host:8000 and see what is going on. It turns out we
       didn't set up the database properly. Our unit tests worked because Django's TestCase
       creates a temporary database in which to store data. But the real one wasn't being
       created or utilized. Django has everything it needs to create the database. This is
       because 1. The database is indicated in settings (it is the default sqlite3 file
       which is generated automatically when we make an app) 2. We performed the
       manage.py migrations function. However, Django needs a direct order to go
       ahead and set up this database. The command is manage.py migrate. We refresh the
       webpage and see that the error page is gone.

BO.    The functional test fails because it is numbering every item with 1, as we
       hardcoded in a little while ago.

BP.    We add another Django feature forloop.counter, which should give us the numbering we desire.

BQ.    The functional test fails at the bookmark. All previous tests passed. However, there is
       a disturbing new development. Every time we run the test, the same two items get added
       anew to the database. So the database keeps getting bigger everytime we run the
       functional tests. We erase the data base, do another migrate to start the process over.
       And now it's time for another Commit.

BR.    COMMIT 12: "Redirect after POST, and show all items in template."

BS.    This is the current state of our to-do list:
       1. Clean up after functional test runs.
       2. Support more than one list!

CHAPTER 6: IMPROVING FUNCTIONAL TESTS: INSURING ISOLATION AND REMOVING VOODOO SLEEPS

A.      Before we improve the project, we have two orders of business. The first is the
        first item of the our to-do list: clean up after functional test runs.
        The other is a new concern. We have time.sleep() functions peppering our
        Functional tests. This is not ideal. So our to-do list is
        1. Clean up after functional tests.
        2. Remove time.sleep
        3. Support more than one list!

B.      To isolate our Functional tests we could write clean-up code in the file.
        However, we can also use a feature of Django: LiveServerTestCase.
        In preparation, we create a new folder called functional_tests. We put
        an empty __init__.py file in the folder. Then we move the functional_tests file
        to functional_tests/tests. The folder functional_tests will be a new app in
        our project. We do the moving with git mv. This way, git can keep track of
        the location of the file. Next, we alter functional_tests/tests to make use
        of LiveServerTestCase. To do so, we add an import django.test.LiveServerTestCase.
        We remove the import of unittest. We make the NewVisitorTest inherit from LiveServerTestCase.
        We change the browser page call in test_can_start_a_list_and_retrieve_it_later to
        self.live_server_url. And we remove the code at the bottom that makes the
        tests file workable as a runable file.
        

C.      The new way to run our functional tests is like this: manage.py test functional_tests.
        This fails at the bookmark, as we expected. More importantly, items are not left
        around from previous test runs.

D.      COMMIT 13 "Make functional_tests an app, use LiveServerTestCase."

E.      Running manage.py test will now run both unit and functional tests. Doing so produces
        the same result: a single fail at the functional test bookmark. 

F.      To run just the unit tests, we now use manage.py test lists. Doing so is successful, as
        expected.

G.      2: Removing time.sleep. Introducing these time.sleep lines is problemmatic. If we don't
        have some wait time, we will face situations where the browser or computer is not able
        to keep up with the test. Then we can have false positives: we get errors that are
        not related to our project. But the problem with these explicit waits is that they
        are almost always too long. One solution is to use implicit waits, a function supplied
        by Selenium. But these are even more troublesome. Most professionals advise us not to
        use them.

H.      Our solution is to change our check_for_row_in_list_table to wait_for_row_in_list_table.
        This uses a loop which continuously checks for the items we are looking for. If the item
        is found, we break out of the loop and go on. Otherwise, we keep looping until a certain
        amount of time has passed and throw the error. We rename our method calls, and remove
        the phantom sleeps.

I.      The Functional test fails at the bookmark, as expected.

J.      Next, we intentionally break the functional test to make sure it catches errors.
        First, we have it look for 'foo' in the database rows.

K.      The Functional test fails because the database does not contain 'foo'. This is expected.

L.      We fix what we broke and break something else. Assigning a value to table, we
        have it find the element by id: 'id_nothing'.

M.      The Functional test fails because there is no element with label 'id_nothing' on the webpage.
        This was also expected.

N.      We fix what we broke.

O.      The functional test fails at the bookmark, as expected. 

CHAPTER 7: WORKING INCREMENTALLY

A.      We are left with one last to-do item: we need to be able to save multiple
        lists. To begin this, we need to flesh out our user story in the functional
        tests a little more, by adding a second user.

B.      We are going to make a move toward REST: REpresentational State Transfer. Each user
        will receive a different webpage.

C.      Here is our new to-do list:
        1.   Adjust model so that items are associated with different lists.
        2.   Add unique URLs for each list.
        3.   Add a URL for creating a new list via POST
        4.   Add URLs for adding a new item to an existing list via POST.

        We will achieve these goals by incrementally chaning the project we have already
        developed.

D.      We begin by altering our functional tests. We change the name of one test, and add
        a new test method test_multiple_users_can_start_lists_at_different_urls. We employ
        assertRegex to assert that the new to-list begins with /lists/ and contains additional text
        after this.

E.      The Functional test fails because the multiple user test cannot find the regex pattern
        /lists/.+ in the URL. This is expected. All previous tests continued to pass, as before.

F.      COMMIT 14: "Functional test expanded to include more than one user"

G.      Since the first part of our Functional Test to fail is item no. 2 on our to-do list, we
        work on that one: Add unique URLs for each list. First, we go to tests.py, in
        test_redirects_after_POST and change the expected redirect location. The name that the
        test looks for is /lists/the-only-list-in-the-world/

H.      The unit tests fail as expected because we aren't redirected to /lists/the-only-list-in-the-world/

I.      We change our home view that so it redirects to /lists/the-only-list-in-the-world/

J.      Functional test fails from the very beginning. It cannot locate the redirect, and it can't
        find anything that it is trying to enter. We have broken our code. Introduced a regression.
        We need to go back and get it working again.

K.      We go back to our unit tests and introduce a new class ListViewTest. We cut out the method
        test_displays_all_list_items, paste it into our new class, change its name by removing "list",
        and alter the response to the the new URL name we are seeking. We are also using
        assertContains, another Django method.

L.      Unit test failed because of a code 404. In short, there is no web page with that name yet
        on the site. This is expected. A nice side-effect of using assertContains, is that it makes
        the source of the error crystal clear.

M.      We go to the urls file and add our new url to the list.

N.      Unit test fails because the view 'view_list' does not exist.

O.      We create a dummy view function in views.

P.      Unit test fails because the few function returns None instead of an HttpResponse object.

Q.      We copy the last two lines from the home_page view function and paste them under view_list.

R.      Unit test passes.

S.      Functional test fails. The project is still broken. We can't add a second item the list.

T.      The problem is that the home.html input fom doesn't specify an explicit URL for the post.
        Rather than doing a complete rewrite with a bunch of new unit tests, we can direct to the home page.

U.      Functional test fails but is back to a happier place. We still cannot have more than one user.

V.      Time for refactoring. We should have two templates, one for home, one for displaying the list.
        First, we create a new unit test. Add test_uses_list_template to ListViewTest.

W.      Unit test fails because there is no list.html template.

X.      Next we change the view to use the list.html template.

Y.      Unit test fails because there is no list.html template.

Z.      We create a list template. An empty file.

AA.     Unit tests fail because the first item is not appearing on the page.

AB.     We copy the home template code to the list template code.

AC.     Unit tests pass.

AD.     Time to refactor. We get rid of the code in the home template that we don't need any more.

AE.     Unit tests pass.

AF.     We go to views, and simplify home_page so that it doesn't send everything to the home page.

AG.     Unit tests pass.

AH.     Functional tests fail. We are still seeing contamination from the previous user in our new user's list.
        This may seem like we have wasted a great deal of time, since the functionality of the product
        is similar to what it was before we started making changes. However, we have begun to completely
        change our code so that things are heading in the right direction. And we didn't break anything in the
        process.

AI.     COMMIT 15: "New URL, view and template to display lists"

AJ.     We review our To-Do list
        1. Adjust model so that items are associated with different lists.
        2. Add unique URLs for each list.
        3. Add a URL for creating a new list via POST
        4. Add URLs for adding a new item to an existing list via POST.

        We worked on #2, but didn't finish it. For now, we will go to #3.

AK.     In the unit tests, we create a new class NewListTest, and move the
        test_redirects_after_POST and test_can_save_a_POST_request methods to
        this class. We also replaced the two asserts in test_redirects_after_POST
        to a single assertRedirects assertion.

AL.     Unit tests fail for two reasons. First, no item gets into the list.
        Second, the redirect is not working. We get a 404 error. This is because
        we don't have a URL in place yet.

AM.     We add a new URL to the urls file.

AN.     Unit tests fail because there is no attribute named "new_list" in the views.

AO.     We add a dummy new_list function to the views.

AP.     Unit tests fail because the new_list function returned None instead of an HttpResponse object.

AQ.     We borrow the redirect from the home page and put it under the new_list function.

AR.     Unit tests fail because the list contains no items.

AS.     We add another line from home_page.

AT.     Unit tests pass.

AU.     Functional test fails for the same reason as before: Contamination from a previous list.

AV.     Now the code in the home_page method is unnecessary. We remove it.

AW.     Unit tests pass.

AX.     We remove the redundant test_only_saves_items_when_necessary

AY.     Unit tests pass.

AZ.     Functional test. Regression. It can't locate id_list_table. It's because our forms are still
        pointing at the old URL.

BA.     We change both templates to send the post to the right page.

BB.     Functional test. Fails where we expect: There is contamination from the previous list.

BC.     COMMIT 16: "Changed URLs, cleaned up views"

BD.     We have completed to-do item number three. Now we go to #1: Adjust model so that items
        are associated with different lists.

BE.     We change the model unit test.

BF.     Unit tests fail because it cannot find List in lists.models

BG.     Created a dummy List class in models.

BH.     Unit tests fails because List has no attribute 'save'

BI.     Make List inhert from django.models.Model

BJ.     Unit tests fail because it can't find the table lists_list

BK.     We makemigrations.

BL.     Unit tests fail because Item object has no attribute "list".

BM.     In models, gave Item a list attribute defined exactly the same way as the text attribute.

BN.     Unit test fails because the database has no column lists_item.list

BO.     We make migrations

BP.     Unit tests fail because the migrations have saved the field "List object" as a text
        label rather than as an object.

BQ.     We adjust the definition of Item.list = models.ForeignKey(List, default=None)

BR.     Since the previous migration was a screw-up, we reverse it.

BS.     We make migrations.

BT.     Unit tests fail badly. The model tests are passing. But three view tests are failing.
        Our new code requires each item to have a parent list. We have not supplied that.

BU.     We change the ListViewTest by creating a parent list for our two test items.

BV.     We change the view so that it includes a parent list when a new item is created.

BW.     Unit tests pass.

BX.     Functional tests fail in the same place as before: there is contamination from prior lists.

BY.     COMMIT 17: "Items now go to different lists."

BZ.     To-do item #2: Each list should have its own URL. To get started, the URL will simply
        be the auto-generated ID field from the database.

CA.     We change the ListViewTest so that the two tests point at new URLs. We change
        test_displays_all_items to test_displays_only_items_for_that_list, and performs
        what it says it does.

CB.     Unit tests fail because the response in the test is seeking a page that doesn't exist.
        Also, no template is being currently used to render this non-existent page.

CC.     We alter the url file so that it recognizes the new pattern based on a regex.

CD.     Unit tests fail for several reasons. The first, and most salient, failure is
        due to the fact that our view function is being given two arguments, when it
        expects only one.

CE.     Added a dummy parameter to the view_list view.

CF.     Unit tests fail because there was cross-list contamination.

CG.     Changed the view_list view so that it can recognize items on a particular list,
        and renders the request to display only the items on THAT list.

CH.     Unit tests fail because the test_redirects_after_POST has not been changed to reflect
        the new situation.

CI.     Fixed test_redirects_after_POST so that it is searching for the correct redirect address.

CJ.     Unit tests fail because of invalid literal...the view is not redirecting to the right address.

CK.     Fix view so it redirects to the correct address.

CL.     Unit tests pass.

CM.     Functional tests fail because each list can only save one item.

CN.     To-do 4: Add URLs for adding a new item to an existing list via POST.

CO.     We create a new unit test class: NewItemTest. It contains these tests:
        test_can_save_a_POST_request_to_an_existing_list, test_redirects_to_list_view

CP.     Unit tests fail in an unexpected way. We have no URL yet for /lists/1/add_item,
        and therefore, we should fail because our reponse code was 404. But instead,
        it failed because our response code was 301, permanently moved. It turns out
        our current URL specification uses a regex that is too greedy. Django automatically
        issues a code of 301 if a URL request is almost correct, but not quite.

CQ.     Changed the end of the final URL regex from (.+)/$ to (\d+)/$.

CR.     Unit tests fail expectedly...code 404, because we don't yet have a URL for
        the new way of doing things.

CS.     Add new URL to deal with adding items.

CT.     Our URLs look rather similar. We add a fifth item to our to-do list: refactor the URLs.

CU.     Unit tests fail because list.views has no attribute 'add_item'.

CV.     We add a dummy method add_item to our views.

CW.     Unit tests fail because add_item is given two arguments but only has one parameter.

CX.     Dummy paramter added to add_item

CY.     Unit tests fail because list.views.add_item returned None instead of an HttpResponse object.

CZ.     redirect from new_list and List.objects.get from view_list copied to add_item.

DA.     Unit tests fail because items are not appearing in the lists.

DB.     alter add_item so it saves the list item.

DC.     Unit tests pass.

DD.     We need to add our new view to our list.html template. We add a new unit test
        test_passes_correct_list_to_template to the unit tests.

DE.     Unit tests fail because we're not passing 'list' to the template, and the \
        test does not recognize this as a key.

DF.     We change view_list in views (making it simpler). When we add an item, the function
        now renders a reqest for 'list.html', and passes the dict {'list': list_}

DG.     This breaks our unit tests. Items are not appearing in the database.

DH.     We fix list.html, adjusting the POST action.

DI.     Unit tests pass.

DJ.     Functional tests pass.

DK.     We have one final item on our to-do list: Refactor away some duplication in urls.py

DL.     COMMIT 18: "new URL + view for adding to existing lists. FT passes."

DM.     Since the url file in superlists is meant for urls seen by the whole project,
        we need to move the app specific urls to a different place. We copy all of the file over
        to /lists/urls. Then we alter /superlists/urls, and /lists/urls

DN.     Unit tests pass.

DO.     COMMIT 19: "Lists app finished for now."

PART II. WEB DEVELOPMENT SINE QUA NONS

CHAPTER 8. PRETTIFICATION: LAYOUT AND STYLING, AND WHAT TO TEST ABOUT IT.

A.      Now we wish to make our site look better. Right now, it's kind of ugly.

B.      Although we should not test aesthetics, we should test the implementation
        of new designs.

C.      New to-do list. We want our site to have
        1.  A large input field.
        2.  A large, attention grabbing, centered box to put our lists in.

D.      We augment our functional tests with a test called test_layout_and_styling

E.      Functional tests fail as expected, because our input box is not currently centered.

F.      To test that the functional test can pass under the right circumstances, we temporarily
        change our home.html template.

G.      Functional tests pass as expected.

H.      We augment our functional tests to make sure that the input box is also center-aligned
        on the page for a new list.

I.      Functional tests fail as expected. The input box is not centered on the page for a new list.

J.      COMMIT 20: "First steps of FT for layout + styling"

K.      When we did this commit, we added functional_tests/tests.py, but not home.html....because this
        was just a temporary solution. We perform a hard reset: git reset --hard, which erases all the
        uncommitted changes.

L.      In reality, we are going to use a CSS framework to solve the design and styling problems.
        We download bootstrap, a venerable such framework, and put it inside a new folder of our
        lists app called "static".

M.      To work properly, bootstrap requires a lot of specific code in our HTML template.
        We do not want to write all of this into both of our templates, so we will make use of
        Django's Template inheritance.

N.      The first thing we need to do, is to make both of these templates inherit from a superclass
        template, which we will now design. We then refactor the home and list html pages to inherit
        from the base case.

O.      Functional tests fail in the same place as before, as expected. The enter box is not yet centered.

P.      COMMIT 21: "Refactor templates to use a base template."

Q.      Not it's time to integrate the code bootstrap expects into the base html document.

R.      Functional tests are still failing in the same place. It seems that the CSS was never loaded.

S.      Django needs to know that the file we are referencing for page design is a static file. In
        the settings, the default prefix for a static folder is /static/. Therefore, we need to change
        our base URL file to search for a static folder.

T.      Functional tests are still failing in the same place. CSS was still not loaded.

U.      This is because we are inheriting from the Django object LiveServerTestCase. We
        need to switch to a new inheritance, from StaticLiveServerTestCase. We change our
        Functional tests, switching the inheritance.

V.      Functional tests pass.

W.      Now, to make the main page header bigger, we use bootstrap's "jumbotron" in the base html.

X.      But now the input text box looks too small. So we set input to large. We add this line to
        the input tag: class="form-control input-lg"

Y.      Adjusted table styling with the addition of Bootstrap table class.

Z.      Wrote a tiny bith of raw CSS code to further tweak the styling.

AA.     Functional tests pass.

AB.     COMMIT 22: "Use Bootstrap to improve layout".

AC.     In preparation for deployment, we add a static file, and adjust the variables referring to
        static files in the settings.

AD.     We run manage.py collectstatic to gather all the static files into our static folder. But
        in so doing, we have also picked up all the CSS files for the admin. Since we are not going
        to be using these for awhile, we should back up.

AE.     In the settings, we comment out the installed app django.contrib.admin. We remove the static
        file and run collectstatic again. This time, only the static files we currently need are
        allocated to the static folder.

AF.     COMMIT 24: "Set STATIC_ROOT in settings and disable admin".

CHAPTER 9: TESTING DEPLOYMENT USING A STAGING SERVER

A.      Fleshed out FT more. It now checks for an environmental variable called STAGING_SERVER

B.      FT fails miserably, as expected. We have no server.

C.      COMMIT 25: Hack FT runner to be able to test staging".

D.      Found my old domain name: beethovenkawaski.com, administered through google domains.

E.      Set up an account on Digital Ocean.

F.      Generated my own ssh key locally.

G.      Created a server ("droplet") on Digital Ocean, attaching the ssh key. (ipv4 of droplet is 159.89.44.252)

H.      Attached the google domain to the server.

I.      Successfully accessed the server via ssh from the terminal.

J.      Generated the account elspeth. Password can be found on LastPass under elspeth@159.89.44.252

K.      Linked ssh key to elspeth and granted elspeth superuser status.

L.      Erased auto-generated root domain and set up apex domains for superlists and superlists-staging. 

E.      Installed Python3.6 and venv on server via the deadsnakes repository.

F.      Installed git on the server. (It was already installed)

G.      Loaded code of this project onto github.

H.      Cloned git from github onto server.

I.      Attempt to run the server failed because Django is not installed on the server.

J.      File requirements.txt created locally containing the text "django==1.11", and added it to git.

K.      COMMIT 23: "Add requirements.txt for virtualenv"

L.      git pushed from local, and git pulled from server.

M.      Set up a virtualenv in the superlists-staging file.

N.      Successfully installed Django on the server, by pip installing (-r) from the requirements.txt file.

O.      Successfully launched the server for the first time.

P.      Functional tests failed because the local bash could not find the website we requested.
        In the code of the attempt, we defined the  STAGING_SERVER variable as our website. We
        also used the --failfast option to manage.py test. This causes the tests to clean up
        and close as soon as the first fail occurs.

Q.      We have pointed Django to our website. We have been running Django on the local host,
        and specified port 8000 in our project code. This causes no problems. But websites are typically run on port
        80, and that is where the functional tests are looking, now that we specified an external website.

R.      Functional tests run again, specifically pointing at port 8000 on the site. The tests fail again for
        the exact same reason.

S.      Attempted a BASH curl (from local bash) on the superlists-staging subdomain. Connection refused.

T.      Attempted to reach the same site directly through Firefox. Connection could not be established.

U.      Performed a BASH curl from the server (using localhost:8000). Success: the contents of the base
        HTML template are printed to the screen.

V.      It turns out that Django's development server is figured to listen in on //127.0.0.1:8000, the
        development server. But we started an external server, at an address that Django is not monitoring.

W.      We shut down the server and restart it, specifying the address 0.0.0.0:8000 (this will cause
        Django to listen on all addresses). Server starts without a hitch.

X.      From the server, curl localhost:8000 works just as before.

Y.      curl from laptap is successful (YES!)

Z.      Attempt to run functional tests fails. Firefox launches, but no page is loaded; not even an
        error page. On server there is an error message that the HTTP_HOST header is invalid

AA.     Added the address of my project to the ALLOWED_HOSTS variable of settings.

AB.     COMMIT 23A. "Address of my project added to ALLOWED_HOSTS"

AC.     Attempt to run Functional Tests had the same results.

AD.     Actually, this error was very similar to the error the book predicted next, but not identical.
        In the book, the server caught the error and displayed it. However, this was not the case
        for my trial. Instead of adding the my site to the allowed host, I used the wildcard *, as
        specified in the book.

AE.     COMMIT 24: "hack ALLOWED_HOSTS to be *" Performed a push and pull.

AF.     Exited and relaunched the server. Server launched as expected.

AG.     curl from the server was successful.

AH.     curl from the laptop was successful.

AI.     Going through Firefox (superlists-staging.beethovenkawasaki.com:8000) was successful: the page
        loaded and the appearance was as expected.

AJ.     Functional tests fail because the table was not found.

AK.     Performed migrate on the server, and restart the server.

AL.     Functional tests passed.

CHAPTER 10: GETTING TO A PRODUCTION-READY DEPLOYMENT

A.      While it is great that our project works on a real-life webpage, it is not really ready
        for prime time. There are several problems.
        (1). Our to-list is presented on port 8000. But people doing everyday web work will be
        automatically directed to port 80.
        (2). The Django development server was not intended for real-life web use. It cannot
        handle the demands and volume of real web-traffic. We will be using the Nginx web server
        and the Gunicorn Python/WSGI server.
        (3). While DEBUG=True is good for development, it is strongly advised to have this set
        to False in production.
        (4). ALLOWED_HOSTS is currently a hack. We want it to allow only the hosts we specify.
        (5). We want our SECRET_KEY to be unique.
        (6). We don't want to ssh in to our server to start the site. We need to write a Systemd
             config file that allows for automatic boot/reboot of the server.

B.      Installed nginx on server. nginx started with systemctl start nginx.

C.      Went directly to the website (without the 8000 port). The nginx welcome page shows up.

D.      Functional tests fail. The tests find the nginx welcome page, and not the expected
        To-do list.

E.      Created a config file on server /etc/nginx/available-sites/superlists-staging.beethovenkawasaki.com
        
F.      Created a symbolic link in sites-enabled to the site file in available-sites. Removed the default
        file in sites-enabled. Restarted nginx and the server.

G.      Functional tests passed.

H.      Installed gunicorn on the server (it was already installed) Also upgraded pip.

I.      We tell gunicorn how to access the WSGI server by using the function "application",
        pointing to the superlists.wsgi file. This appears to run the site on the server.

J.      Functional tests fail because the formatting information was not found. (the static files.)

K.      While Django automatically serves up static files, gunicorn does not. We can use nginx for
        that.

L.      Used collectstatic to gather static files for the server.

M.      Altered the file /etc/nginx/sites-available/$SITENAME to include the location of the static files.

        NOTE: To do this on emacs, we use TRAMP. Here is the way it is done.
        1.    Use the key combination for opening a file, namely C-X C-F.
        2.    Backspace until you are in the root directory.
        3.    Enter /ssh:user@server|sudo:server:/desired/file/path
        4.    The first time you do this, you are asked for the password.
              After you enter it correctly, you will be presented with the option
              to save this password. If you select y, you will never need
              to enter the password again for this particular account.

N.      Restarted nginx like this: sudo systemctil reload nginx
O.      Moved to the /sites/superlists-staging.beethovenkawasaki.com folder and started gunicorn server like this:
        ./virtualenv/bin/gunicorn superlists.wsgi:application

P.      Ran the browser, and the site has the expected appearance.

Q.      Functional tests passed.
        NOTE: The new way of running functional tests is this:

        STAGING_SERVER=staging-server-name.sitename.com python manage.py test functional_tests --failfast
        The failfast option causes the testing to cease at the first failure.

R.      We will eventually be going to a production server. We want to be able to use the staging server
        and the functional server. They cannot both share the same port. We do not wish to arbitrarily assign
        two different ports. Instead, we will use a unix socket.
        We alter the sites-available file for our staging site so that the proxy_pass under the second
        location entry reads as follows:
        http://unix:/tmp/our-staging-site-name.com.socket;

S.      We restart the Gunicorn server, telling it to listen in on the socket instead of the default port.

T.      Functional tests pass.

U.      To have a production-ready site, we need to make a few changes to our current setup. These are:
        1. Get rid of the hack of the ALLOWED_HOSTS variable. The current wildcard entry is not secure.
        We want it only to match the site that we plan to serve on.

        2. The DEBUG mode is set to True. This was useful for the development and staging stages, but
        is insecure for the production site. This needs to be changed.

        3. The SECRET_KEY is used by Django. We do not want the server to have the same secret key as our
        local code. We need to generate a new secret key.

V.      We go to our local superlists/settings.py file and make these changes. We accomplish this by
        branching and environment variables.

W.      COMMIT 25: "Use env vars for prod settings DEBUG, ALLOWED_HOSTS, SECRET_KEY"

Y.      Used export to temporarily set the variables DJANGO_DEBUG_FALSE DJANGO_SECRET_KEY

Z.      Functional tests failed because "To-Do" was not found on the webpage. A look on the browser
        shows a bad request 400.

AA.     Nginx by default strips out the Host headers, and it appears that the page comes from localhost.
        We add the proxy_set_header directive to the sites-available/SITENAME file.

AB.     Functional tests pass.

AC.     We have been entering environment variables directly in the shell. But this is a pain in the ass.
         We make an .env file












