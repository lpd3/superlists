PREREQUISITES AND ASSUMPTIONS

Assumptions:	
1.	You know how to write code in Python 3
2.	You have a basic knowledge of HTML
3.	You are willing to learn some Django
4.	You are willing to learn some JavaScript

Prerequisites:
1.	Firefox web browser
2.	Git version control system.
3.	A virtualenv with Python 3, Django 1.11 and Selenium 3 in it.
4.	Geckodriver

PART I: THE BASICS OF TDD AND DJANGO

CHAPTER 1: GETTING DJANGO SET UP USING A FUNCTIONAL TEST

A.	Functional test written which checks to make sure “Django” is in the web-page title.
	
	Running this test fails. We don’t yet have a server up and running.
	
B.	New project “superlists” created using django-admin.py
C.	Server started using manage.py

D.	Functional test run again.

	Running test passes.

E. 	Git repository started.
	Files that we don’t want tracked are added to .gitignore
F.	COMMIT 1: “First Commit: First FT and Basic Django config.

CHAPTER 2: EXTENDING OUR FUNCTIONAL TEST USING THE unittest  MODULE

Project revealed: A To-Do List

A.	Functional Test redesigned: User story created. Test now checks that the text “To-Do” appears 
	in the browser title.

B.	Test run and fails: The Assertion fails. This is cryptic. Furthermore, the process annoyingly 
	leaves an open browser window hanging around.

C.	Functional Test rewritten using the python module unittest. Groups of tests are classes.
	Individual tests are methods within the classes that begin with the word “test”. The name
	of each test should be highly descriptive. Each class may have an unlimited number of tests.
	The classes may include other methods besides tests. Two useful ones are
	setUp

	and

	tearDown.

	These designate the actions that the test class will take at the beginning and at the end, 
	regardless of whether or not there is an error.

	Some useful unittest functions:

	assertIn(object, location)
	A special assertion that is much more descriptive that the default assert.

	fail(message)
	A function that always fails. Useful as a testing “bookmark”.

D.	Functional test run again. Fails the assertIn test, giving a message that “To-Do” does not appear
	in the browser title.

E.	COMMIT 2: “First FT specced out in comments, and now uses unittest.”

CHAPTER 3: TESTING A SIMPLE HOME PAGE WITH UNIT TESTS

A.	First app created for our project, called “lists.” Created with manage.py startapp

B.      First (silly) unittest written.

C.      COMMIT 3: "Add app for lists, with deliberately failing unit test."

D.      Rewrote the unittests. class HomePageTest. def test_root_url_resolved_to_home_page_view

E.      Test failed because the home_page import from lists.views has not been written.

F.      home_page declared in views as equal to None

G.      Test failed because there is no URL associated with our view.

H.      Went to superlists/urls.py and got rid of admin import,
        replaced it with lists.views import and altered the first urlpattern to send to the homepage on empty text.

I.      Test failed because home_page as defined is not callable, or a list/tuple.

J.      In views, redefined home_page as a function that does nothing.

K.      Unittest passed.

L.      COMMIT 4: "First unit test and url mapping, dummy view."

M.      /lists/tests: added import to django.http.HttpRequest. Added a new test method to the class,
        test_home_page_returns_correct_html. Wrote code to make home_page the response based on the request,
        to decode the bytes into utf8 and call this html, and assertions that this begins with the html tag,
        contains the title To-Do lists and ends with the close html tag.

N.      Unittest fails because it is sending an argument to home_page, which currently has no parameters.

O.      Changed home_page view to take a single parameter called "request".

P.      Unittest fails because the test is expecting the return value from home_page to have an attribute called
        "content." But the home_page view returns None.

Q.      in views, added an import to django.http.HttpResponse. Rewrote the home_page function so that it returns
        HttpResponse.

R.      Unit test fails because the decoded response does not begin with the html tag.

S.      Added html tag to views.

T.      Unit test fails because it does not contain the title.

U.      Added title to views.

V.      Unit test fails because it doesn't end with html close tag.

W.      html close tag added to views.

X.      Unit test passes.

Y.      Functional test fails at our bookmark failure only.

Z.      COMMIT 5: "Basic view now returns minimal HTML"

CHAPTER 4. WHAT ARE WE DOING WITH ALL THESE TESTS? (AND REFACTORING)

A.      Ran the Functional Test and got the same error at our bookmark.

B.      Fleshed out the Functional Test much more. Now imports Keys from Selenium.
        Locates the header text and tests to see if
        To-Do is in the text. Tests to make sure the inputbox contains the text 'Enter a to-do item'.
        Sends the key 'Buy peacock feathers'. Enters them. Sleeps for 1 second. Finds the rows of the
        table and verifies that the text '1: Buy peacock featers' appears somewhere in the table.
        Moved the failure bookmark here.
        We used a few new Selenium functions: find_element_by_tag_name, find_element_by_id, get_attribute
        send_keys, Keys.ENTER

C.      Functional Test failed because element 'h1' is not on the page.

D.      COMMIT 6: "Functional test now checks we can add a to-do item"

E.      Since the unit testing we currently have tests constants (not really what unit tests are for)
        we are going to relegate the content of views to files written in HTML. This is refactoring.
        We are attempting to improve the code while maintaining the same functionality. This requires
        tests. The first thing we do is re-run our current unit tests. These passed, as expected.

F.      Created the directory lists/templates. Created a HTML file in lists/templates called home.html. It contains exactly the same
        content that the previous "hard-wired" view does.

G.      Changed the views file. We got rid of the hard-coded stuff. We got rid of the
        htmlrequest import. Now the home_page function returns the render(request, 'home.html')

H.      Unit test fails because home.html is not recognized as a template.

I.      We realize that having an html file in the templates file is not enough to use it in rendering a view.
        We need to register the lists app in the superlists/settings file. This is put in the INSTALLED_APPS.

J.      Unit test fails because the page does not end in '</html>/'. This is because converting the view to
        a template resulted in an inavertant addition of a newline.

K.      Since it does not matter if there is whitespace at the end of the page, we change the test to
        check on the presence of the stripped html close tag.

L.      Unit test passes.

M.      Change the unit test so that it no longer checks for specific test. Instead, it checks to make
        sure the correct template is utilized.

N.      Unit Test passes.

O.      Since test didn't fail, we create a deliberately failing condition to check it: we give it the wrong
        name for the template. And it fails as expected. We replace the correct template.

P.      Removed the test_root_url_resolves test. Removed all assertions except the assertTemplateUsed.
        django's client.get takes care of everything else.

Q.      did a git add . because we now have a new html file to keep track of.

R.      COMMIT 7: "Refactor home page view to use a template."

S.      Since the functional test will still fail...the page still does not include h1...we now can change
        our template to have this. And since we have a template, we do not need to create new unit tests
        to test the functionality of the addition.

T.      Functional tests fail because the element with id "id_new_item" cannot be found in the page.

U.      Changed the template to include an input with id tag "id_new_item"

V.      Functional tests fail because "Enter a to-do item" is not found in the page.

W.      We add our placeholder variable to the home page.

X.      Functional tests fail because the element with id "id_list_table" is not found on the page.

Y.      We put an empty table in home with the correct id.

Z.      Functional tests fail because "1: Buy peacock feathers" is not found in table. Also, the error
        message is cryptic on behalf of the assertTrue function. We add an explicit error message to
        this function.

AA.     Functional tests fail again for the same reason. But now we have a more understandable error
        message.

AB.     COMMIT 8: "Front page HTML now generated from a template."

CHAPTER 5. SAVING USER INPUT: TESTING THE DATABASE

A.      We need to be able to save user input. Our first attempts at this will involve simple
        POST requests. We need to update our home.html template. The <input> element is given a name
        and it is wrapped in a <form> tag with method = "POST"

B.      Functional test fails for an unexpected reason. Error message is cryptic. We decide to extend
        the already present "sleep" function in the functional test to allow us a good look at the webpage.

C.      It turns out, that the Functional test fails because Django is expecting a CSRF token. A CSRF =
        Cross-Site Forgery Request = a type of attack that relies on hijacking a user's POST requests
        to access aspects of a site that the hacker would not normally have access to. Django's solution
        to this problem is to generate, and check for the presence of, a random key in the document.
        The hacker will not have this key and will not be able to hijack the post request. To make
        get Django to generate this tag, we will insert {% csrf_token %} into our form on the template.

D.      Functional test fails because the test item did not make it into the table. The problem is that
        the views file is not set up to deal with a POST request. It simply directs everything to the
        home page, which does us no good.

E.      We replace the original sleep duration in the functional test. Then we add a new test in the unit
        tests. test_can_save_a_POST_request.

F.      The Unit test fails as expected. We need to get the views to recognize a POST request.

G.      The simplest way to get the unit test to pass is to rewrite the views to return a POST request
        when an item is sent to the list.

H.      The Unit test passes. However, we are not accomplishing what we wish to accomplish. The
        item is not being added to list database.

I.      We change our home template. We add the Python variable new_item_text to the a row of the table,
        and enclose this in double braces, which will render the variable as a string. Then we adjust the
        unit test to test whether or not the home template is still being used to render the POST request.

J.      The unit test fails, as expected.

K.      We simplify our home page view to allow for a post request for a new item.

L.      The unit test fails for an unexpected reason: in redesigning our views, we accidentally got rid
        of the POST request.

M.      We alter the view so that it uses request.POST.get. It takes the variable name, and we also
        give it a default value, the empty string.


N.      The unit test passes.

O.      The functional tests fails. The new to-do item is still not appearing in the table. This is
        an unexpected error.

P.      We improve the error message in the assertion function that shows us the contents of the
        table. We used the f string syntax, introduced in Python 3.6

Q.      Functional test fails again, as expected. This time we see that the item made it into the table,
        but that it contains no "1", which we wanted the table entry to contain.

R.      We realize that our assertion is overly complex. We were trying to be too clever by using
        the Python "all" built-in function. We change the assertion to make it much simpler, and
        function better.

S.      The Functional test fails as expected. This time, we get a clear error message as a side-effect
        of our simpler assertion.

T.      The fastest way to fix this error is simply to write a 1 in the template. We do this.

U.      The Functional test fails at the bookmark. All earlier tests pass. But of course, this
        cannot be the permanent solution...because we don't want every list item to contain the
        number 1.

V.      We complete more of our Functional Test. Now, in addition, it will check a second item, and
        see if both items are in the database. In so doing, it will check that the second item
        begins with a "2".

W.      Functional test fails because the first entry was not retained in the list.

X.      We pause because, in addition to the fail, we have a "bad code smell." The code is getting
        repetitive. We need to refactor to remove duplication before we fix the problem. Before doing a
        refactor, we always make a commit.

Y.      COMMIT 9: "To-Do list now can handle user input."

Z.      We add a hepler method to the functional test (not beginning with "test"): check_for_row_in_list_table.
        Then we remove the two sections of code that did this same check and replace them with calls to
        the helper method.

AA.     The functional test fails, as expected, and in the same way. This is good news. It means our
        refactoring did not change the way the site or the tests work.

AB.     COMMIT 10: Functional test refactoring: Checking for text within rows is now accomplished by a helper function.

AC.     To get the site to retain items, we must put them in a database. Working with databases in object-oriented
        languages is usually accomplished through a ORM: Object-Relational Manager.
        Tables are classes. Columns are attributes. Rows are instances of the class. Django has a very good ORM,
        and we will use it. We alter tests.py. First we add an import: from lists.models import Item. Then we write
        a new class: ItemModelTest. In this new class, we add a new test method: test_saving_and_retrieving_items.

        New Django functions: .save() saves an item with its attributes to a database.
                              .objects() allows us to query the database.
                              .all() is the simplest query: it retrieves all items for the table.
                              The items are returned in a list-like object called a QuerySet
                              .count() returns the count of entries in the QuerySet

AD.    Unit test fails because it cannot find the import lists.models.Item.

AE.    We create a class in models called Item. It does nothing.

AF.    Unit test fails because Item has no attribute "save".

AG.    We change Item so that it inherits from Django's Model class.

AH.    Unit test fails because it can't find a table called "lists_item". Although we've defined
       a table in our template, we have no actual table.

AI.    We rely on a separate Django system
       called "migrations" which moves our information over to an actual table. We need
       to make migrations. We do this the first time with running manage.py makemigrations

AJ.    Unit test fails because Item has no attribute "text".

AK.    The models.Models object maps tables to a database. It automatically generates an id
       attribute for each item, but must be instructed how to deal with the information we
       provide. We change our Item class and add text = models.TextField(). Django has
       many other field types.

AL.    Unit test fails because it does not recognize the "lists_item.text" as a column name.

AM.    Since we added a column, we need to do another migration. We try the same method we used before.

AN.    This attempt fails. We need to either give a universal default, or set one up in models.py.

AO.    We alter the definition of "text" in the Item class of models.py so that it carries the
       argument "default=''", the default is the empty string.

AP.    We attempt to run makemigrations again and it works.

AQ.    Unit tests pass.

AR.    We add "lists" to our git.

AS.    COMMIT 11: "Model for list Items and associated migration"

AT.    We expand the unit tests. Now test_can_save_a_POST_request checks to see if the item was added to
       the database, and just rendered as a RESPONSE. While we're at it, we notice that this test is
       getting long. It is issuing a "code smell." We make a to-do list of our own. And the sole
       item on the list is POST request test too long?

AU.    Unit test fails because there are no items in the database.

AV.    We adjust our view. We import lists.models. We redo the home_page view to accept and save a POST request
       wrapped in an Item. Our naive solution saves an empty item to the database every time we request the
       home page. We add this problem to our to-do list.

AW.    Unit tests passed.

AX.    We refactor a little in the views.

AY.    Now we have a to-do list with four items.
       1.  Don't save blank lines for every request.
       2.  Code smell: POST test is too long?
       3.  Display multiple items in the table.
       4.  Support more than one list!

AZ.    Item no. 1: Don't save blank lines for every request. We create a new test method in our HomePageTest
       to make sure simple redirects no not POST anything to the table.

BA.    Unit test fails as expected because there was an empty entry posted on simple redirect.

BB.    We tweek the views to fix this problem.

BC.    Unit test passes.

BD.    We need to refactor. The new_item_text = '' is lame. And, following the dictum of "always
       redirect after a POST", we alter our unit tests again. We assert that the response status
       code = 302 and we assert that the location of the response is home.

BE.    Unit test fails because status code is 200. 302 is the status code for redirect. 200
       is the status code for "user has requested documents and they were successfully delivered."

BF.    We tidy up our view. We add an import django.shortcuts.redirect. Then we simply return
       a request of home.html if this is not a post.

BG.    Unit test passes.

BH.    2. Code smell: POST test too long?
       Now, we should test only one thing at a time. In other words, each unit test method should
       contain only one assertion. So we refactor the unit tests to obey this dictum.

BI.    Unit test passes, as expected. Now we have five unit test methods instead of four, but
       these are testing the same things as before.

BJ.    3. Display multiple items in the table. We create a new unit test method
       test_displays_all_list_items

BK.    Unit test fails as expected. The first test item does not appear in the response content.

BL.    We alter the home.html template to allow the table to be iterated through. Then we change our
       home page view to pass the items to the template.

BM.    Unit test passes.

BN.    Functional Test fails for a cryptic reason. We decide to try a new debugging technique: we
       open up the browser at http://local-host:8000 and see what is going on. It turns out we
       didn't set up the database properly. Our unit tests worked because Django's TestCase
       creates a temporary database in which to store data. But the real one wasn't being
       created or utilized. Django has everything it needs to create the database. This is
       because 1. The database is indicated in settings (it is the default sqlite3 file
       which is generated automatically when we make an app) 2. We performed the
       manage.py migrations function. However, Django needs a direct order to go
       ahead and set up this database. The command is manage.py migrate. We refresh the
       webpage and see that the error page is gone.

BO.    The functional test fails because it is numbering every item with 1, as we
       hardcoded in a little while ago.

BP.    We add another Django feature forloop.counter, which should give us the numbering we desire.

BQ.    The functional test fails at the bookmark. All previous tests passed. However, there is
       a disturbing new development. Every time we run the test, the same two items get added
       anew to the database. So the database keeps getting bigger everytime we run the
       functional tests. We erase the data base, do another migrate to start the process over.
       And now it's time for another Commit.

BR.    COMMIT 12: "Redirect after POST, and show all items in template."

BS.    This is the current state of our to-do list:
       1. Clean up after functional test runs.
       2. Support more than one list!

CHAPTER 6: IMPROVING FUNCTIONAL TESTS: INSURING ISOLATION AND REMOVING VOODOO SLEEPS

A.      Before we improve the project, we have two orders of business. The first is the
        first item of the our to-do list: clean up after functional test runs.
        The other is a new concern. We have time.sleep() functions peppering our
        Functional tests. This is not ideal. So our to-do list is
        1. Clean up after functional tests.
        2. Remove time.sleep
        3. Support more than one list!

B.      To isolate our Functional tests we could write clean-up code in the file.
        However, we can also use a feature of Django: LiveServerTestCase.
        In preparation, we create a new folder called functional_tests. We put
        an empty __init__.py file in the folder. Then we move the functional_tests file
        to functional_tests/tests. The folder functional_tests will be a new app in
        our project. We do the moving with git mv. This way, git can keep track of
        the location of the file. Next, we alter functional_tests/tests to make use
        of LiveServerTestCase. To do so, we add an import django.test.LiveServerTestCase.
        We remove the import of unittest. We make the NewVisitorTest inherit from LiveServerTestCase.
        We change the browser page call in test_can_start_a_list_and_retrieve_it_later to
        self.live_server_url. And we remove the code at the bottom that makes the
        tests file workable as a runable file.
        

C.      The new way to run our functional tests is like this: manage.py test functional_tests.
        This fails at the bookmark, as we expected. More importantly, items are not left
        around from previous test runs.

D.      COMMIT 13 "Make functional_tests an app, use LiveServerTestCase."

E.      Running manage.py test will now run both unit and functional tests. Doing so produces
        the same result: a single fail at the functional test bookmark. 

F.      To run just the unit tests, we now use manage.py test lists. Doing so is successful, as
        expected.

G.      2: Removing time.sleep. Introducing these time.sleep lines is problemmatic. If we don't
        have some wait time, we will face situations where the browser or computer is not able
        to keep up with the test. Then we can have false positives: we get errors that are
        not related to our project. But the problem with these explicit waits is that they
        are almost always too long. One solution is to use implicit waits, a function supplied
        by Selenium. But these are even more troublesome. Most professionals advise us not to
        use them.

H.      Our solution is to change our check_for_row_in_list_table to wait_for_row_in_list_table.
        This uses a loop which continuously checks for the items we are looking for. If the item
        is found, we break out of the loop and go on. Otherwise, we keep looping until a certain
        amount of time has passed and throw the error. We rename our method calls, and remove
        the phantom sleeps.

I.      The Functional test fails at the bookmark, as expected.

J.      Next, we intentionally break the functional test to make sure it catches errors.
        First, we have it look for 'foo' in the database rows.

K.      The Functional test fails because the database does not contain 'foo'. This is expected.

L.      We fix what we broke and break something else. Assigning a value to table, we
        have it find the element by id: 'id_nothing'.

M.      The Functional test fails because there is no element with label 'id_nothing' on the webpage.
        This was also expected.

N.      We fix what we broke.

O.      The functional test fails at the bookmark, as expected. 

CHAPTER 7: WORKING INCREMENTALLY

A.      We are left with one last to-do item: we need to be able to save multiple
        lists. To begin this, we need to flesh out our user story in the functional
        tests a little more, by adding a second user.

B.      We are going to make a move toward REST: REpresentational State Transfer. Each user
        will receive a different webpage.

C.      Here is our new to-do list:
        1.   Adjust model so that items are associated with different lists.
        2.   Add unique URLs for each list.
        3.   Add a URL for creating a new list via POST
        4.   Add URLs for adding a new item to an existing list via POST.

        We will achieve these goals by incrementally chaning the project we have already
        developed.

D.      We begin by altering our functional tests. We change the name of one test, and add
        a new test method test_multiple_users_can_start_lists_at_different_urls. We employ
        assertRegex to assert that the new to-list begins with /lists/ and contains additional text
        after this.

E.      The Functional test fails because the multiple user test cannot find the regex pattern
        /lists/.+ in the URL. This is expected. All previous tests continued to pass, as before.

F.      COMMIT 14: "Functional test expanded to include more than one user"

G.      Since the first part of our Functional Test to fail is item no. 2 on our to-do list, we
        work on that one: Add unique URLs for each list. First, we go to tests.py, in
        test_redirects_after_POST and change the expected redirect location. The name that the
        test looks for is /lists/the-only-list-in-the-world/

H.      The unit tests fail as expected because we aren't redirected to /lists/the-only-list-in-the-world/

I.      We change our home view that so it redirects to /lists/the-only-list-in-the-world/

J.      Functional test fails from the very beginning. It cannot locate the redirect, and it can't
        find anything that it is trying to enter. We have broken our code. Introduced a regression.
        We need to go back and get it working again.

K.      We go back to our unit tests and introduce a new class ListViewTest. We cut out the method
        test_displays_all_list_items, paste it into our new class, change its name by removing "list",
        and alter the response to the the new URL name we are seeking. We are also using
        assertContains, another Django method.

L.      Unit test failed because of a code 404. In short, there is no web page with that name yet
        on the site. This is expected. A nice side-effect of using assertContains, is that it makes
        the source of the error crystal clear.

M.      We go to the urls file and add our new url to the list.

N.      Unit test fails because the view 'view_list' does not exist.

O.      We create a dummy view function in views.

P.      Unit test fails because the few function returns None instead of an HttpResponse object.

Q.      We copy the last two lines from the home_page view function and paste them under view_list.

R.      Unit test passes.

S.      Functional test fails. The project is still broken. We can't add a second item the list.

T.      The problem is that the home.html input fom doesn't specify an explicit URL for the post.
        Rather than doing a complete rewrite with a bunch of new unit tests, we can direct to the home page.

U.      Functional test fails but is back to a happier place. We still cannot have more than one user.

V.      Time for refactoring. We should have two templates, one for home, one for displaying the list.
        First, we create a new unit test. Add test_uses_list_template to ListViewTest.

W.      Unit test fails because there is no list.html template.

X.      Next we change the view to use the list.html template.

Y.      Unit test fails because there is no list.html template.

Z.      We create a list template. An empty file.

AA.     Unit tests fail because the first item is not appearing on the page.

AB.     We copy the home template code to the list template code.

AC.     Unit tests pass.

AD.     Time to refactor. We get rid of the code in the home template that we don't need any more.

AE.     Unit tests pass.

AF.     We go to views, and simplify home_page so that it doesn't send everything to the home page.

AG.     Unit tests pass.

AH.     Functional tests fail. We are still seeing contamination from the previous user in our new user's list.
        This may seem like we have wasted a great deal of time, since the functionality of the product
        is similar to what it was before we started making changes. However, we have begun to completely
        change our code so that things are heading in the right direction. And we didn't break anything in the
        process.

AI.     COMMIT 15: "New URL, view and template to display lists"

AJ.     We review our To-Do list
        1. Adjust model so that items are associated with different lists.
        2. Add unique URLs for each list.
        3. Add a URL for creating a new list via POST
        4. Add URLs for adding a new item to an existing list via POST.

        We worked on #2, but didn't finish it. For now, we will go to #3.

AK.     In the unit tests, we create a new class NewListTest, and move the
        test_redirects_after_POST and test_can_save_a_POST_request methods to
        this class. We also replaced the two asserts in test_redirects_after_POST
        to a single assertRedirects assertion.

AL.     Unit tests fail for two reasons. First, no item gets into the list.
        Second, the redirect is not working. We get a 404 error. This is because
        we don't have a URL in place yet.

AM.     We add a new URL to the urls file.

AN.     Unit tests fail because there is no attribute named "new_list" in the views.

AO.     We add a dummy new_list function to the views.

AP.     Unit tests fail because the new_list function returned None instead of an HttpResponse object.

AQ.     We borrow the redirect from the home page and put it under the new_list function.

AR.     Unit tests fail because the list contains no items.

AS.     We add another line from home_page.

AT.     Unit tests pass.

AU.     Functional test fails for the same reason as before: Contamination from a previous list.

AV.     Now the code in the home_page method is unnecessary. We remove it.

AW.     Unit tests pass.

AX.     We remove the redundant test_only_saves_items_when_necessary

AY.     Unit tests pass.

AZ.     Functional test. Regression. It can't locate id_list_table. It's because our forms are still
        pointing at the old URL.

BA.     We change both templates to send the post to the right page.

BB.     Functional test. Fails where we expect: There is contamination from the previous list.

BC.     COMMIT 16: "Changed URLs, cleaned up views"

BD.     We have completed to-do item number three. Now we go to #1: Adjust model so that items
        are associated with different lists.

BE.     We change the model unit test.

BF.     Unit tests fail because it cannot find List in lists.models

BG.     Created a dummy List class in models.

BH.     Unit tests fails because List has no attribute 'save'

BI.     Make List inhert from django.models.Model

BJ.     Unit tests fail because it can't find the table lists_list

BK.     We makemigrations.

BL.     Unit tests fail because Item object has no attribute "list".

BM.     In models, gave Item a list attribute defined exactly the same way as the text attribute.

BN.     Unit test fails because the database has no column lists_item.list

BO.     We make migrations

BP.     Unit tests fail because the migrations have saved the field "List object" as a text
        label rather than as an object.

BQ.     We adjust the definition of Item.list = models.ForeignKey(List, default=None)

BR.     Since the previous migration was a screw-up, we reverse it.

BS.     We make migrations.

BT.     Unit tests fail badly. The model tests are passing. But three view tests are failing.
        Our new code requires each item to have a parent list. We have not supplied that.

BU.     We change the ListViewTest by creating a parent list for our two test items.

BV.     We change the view so that it includes a parent list when a new item is created.

BW.     Unit tests pass.

BX.     Functional tests fail in the same place as before: there is contamination from prior lists.

BY.     COMMIT 17: "Items now go to different lists."

BZ.     To-do item #2: Each list should have its own URL. To get started, the URL will simply
        be the auto-generated ID field from the database.

CA.     We change the ListViewTest so that the two tests point at new URLs. We change
        test_displays_all_items to test_displays_only_items_for_that_list, and performs
        what it says it does.

CB.     Unit tests fail because the response in the test is seeking a page that doesn't exist.
        Also, no template is being currently used to render this non-existent page.

CC.     We alter the url file so that it recognizes the new pattern based on a regex.

CD.     Unit tests fail for several reasons. The first, and most salient, failure is
        due to the fact that our view function is being given two arguments, when it
        expects only one.

CE.     Added a dummy parameter to the view_list view.

CF.     Unit tests fail because there was cross-list contamination.

CG.     Changed the view_list view so that it can recognize items on a particular list,
        and renders the request to display only the items on THAT list.

CH.     Unit tests fail because the test_redirects_after_POST has not been changed to reflect
        the new situation.

CI.     Fixed test_redirects_after_POST so that it is searching for the correct redirect address.

CJ.     Unit tests fail because of invalid literal...the view is not redirecting to the right address.

CK.     Fix view so it redirects to the correct address.

CL.     Unit tests pass.

CM.     Functional tests fail because each list can only save one item.

CN.     To-do 4: Add URLs for adding a new item to an existing list via POST.

CO.     We create a new unit test class: NewItemTest. It contains these tests:
        test_can_save_a_POST_request_to_an_existing_list, test_redirects_to_list_view

CP.     Unit tests fail in an unexpected way. We have no URL yet for /lists/1/add_item,
        and therefore, we should fail because our reponse code was 404. But instead,
        it failed because our response code was 301, permanently moved. It turns out
        our current URL specification uses a regex that is too greedy. Django automatically
        issues a code of 301 if a URL request is almost correct, but not quite.

CQ.     Changed the end of the final URL regex from (.+)/$ to (\d+)/$.

CR.     Unit tests fail expectedly...code 404, because we don't yet have a URL for
        the new way of doing things.

CS.     Add new URL to deal with adding items.

CT.     Our URLs look rather similar. We add a fifth item to our to-do list: refactor the URLs.

CU.     Unit tests fail because list.views has no attribute 'add_item'.

CV.     We add a dummy method add_item to our views.

CW.     Unit tests fail because add_item is given two arguments but only has one parameter.

CX.     Dummy paramter added to add_item

CY.     Unit tests fail because list.views.add_item returned None instead of an HttpResponse object.

CZ.     redirect from new_list and List.objects.get from view_list copied to add_item.

DA.     Unit tests fail because items are not appearing in the lists.

DB.     alter add_item so it saves the list item.

DC.     Unit tests pass.

DD.     We need to add our new view to our list.html template. We add a new unit test
        test_passes_correct_list_to_template to the unit tests.

DE.     Unit tests fail because we're not passing 'list' to the template, and the \
        test does not recognize this as a key.

DF.     We change view_list in views (making it simpler). When we add an item, the function
        now renders a reqest for 'list.html', and passes the dict {'list': list_}

DG.     This breaks our unit tests. Items are not appearing in the database.

DH.     We fix list.html, adjusting the POST action.

DI.     Unit tests pass.

DJ.     Functional tests pass.

DK.     We have one final item on our to-do list: Refactor away some duplication in urls.py

DL.     COMMIT 18: "new URL + view for adding to existing lists. FT passes."

DM.     Since the url file in superlists is meant for urls seen by the whole project,
        we need to move the app specific urls to a different place. We copy all of the file over
        to /lists/urls. Then we alter /superlists/urls, and /lists/urls

DN.     Unit tests pass.

DO.     COMMIT 19: "Lists app finished for now."

PART II. WEB DEVELOPMENT SINE QUA NONS

CHAPTER 8. PRETTIFICATION: LAYOUT AND STYLING, AND WHAT TO TEST ABOUT IT.

A.      Now we wish to make our site look better. Right now, it's kind of ugly.

B.      Although we should not test aesthetics, we should test the implementation
        of new designs.

C.      New to-do list. We want our site to have
        1.  A large input field.
        2.  A large, attention grabbing, centered box to put our lists in.

D.      We augment our functional tests with a test called test_layout_and_styling

E.      Functional tests fail as expected, because our input box is not currently centered.

F.      To test that the functional test can pass under the right circumstances, we temporarily
        change our home.html template.

G.      Functional tests pass as expected.

H.      We augment our functional tests to make sure that the input box is also center-aligned
        on the page for a new list.

I.      Functional tests fail as expected. The input box is not centered on the page for a new list.

J.      COMMIT 20: "First steps of FT for layout + styling"

K.      When we did this commit, we added functional_tests/tests.py, but not home.html....because this
        was just a temporary solution. We perform a hard reset: git reset --hard, which erases all the
        uncommitted changes.

L.      In reality, we are going to use a CSS framework to solve the design and styling problems.
        We download bootstrap, a venerable such framework, and put it inside a new folder of our
        lists app called "static".

M.      To work properly, bootstrap requires a lot of specific code in our HTML template.
        We do not want to write all of this into both of our templates, so we will make use of
        Django's Template inheritance.

N.      The first thing we need to do, is to make both of these templates inherit from a superclass
        template, which we will now design. We then refactor the home and list html pages to inherit
        from the base case.

O.      Functional tests fail in the same place as before, as expected. The enter box is not yet centered.

P.      COMMIT 21: "Refactor templates to use a base template."

Q.      Not it's time to integrate the code bootstrap expects into the base html document.

R.      Functional tests are still failing in the same place. It seems that the CSS was never loaded.

S.      Django needs to know that the file we are referencing for page design is a static file. In
        the settings, the default prefix for a static folder is /static/. Therefore, we need to change
        our base URL file to search for a static folder.

T.      Functional tests are still failing in the same place. CSS was still not loaded.

U.      This is because we are inheriting from the Django object LiveServerTestCase. We
        need to switch to a new inheritance, from StaticLiveServerTestCase. We change our
        Functional tests, switching the inheritance.

V.      Functional tests pass.

W.      Now, to make the main page header bigger, we use bootstrap's "jumbotron" in the base html.

X.      But now the input text box looks too small. So we set input to large. We add this line to
        the input tag: class="form-control input-lg"

Y.      Adjusted table styling with the addition of Bootstrap table class.

Z.      Wrote a tiny bith of raw CSS code to further tweak the styling.

AA.     Functional tests pass.

AB.     COMMIT 22: "Use Bootstrap to improve layout".

AC.     In preparation for deployment, we add a static file, and adjust the variables referring to
        static files in the settings.

AD.     We run manage.py collectstatic to gather all the static files into our static folder. But
        in so doing, we have also picked up all the CSS files for the admin. Since we are not going
        to be using these for awhile, we should back up.

AE.     In the settings, we comment out the installed app django.contrib.admin. We remove the static
        file and run collectstatic again. This time, only the static files we currently need are
        allocated to the static folder.

AF.     COMMIT 24: "Set STATIC_ROOT in settings and disable admin".

CHAPTER 9: TESTING DEPLOYMENT USING A STAGING SERVER

A.      Fleshed out FT more. It now checks for an environmental variable called STAGING_SERVER

B.      FT fails miserably, as expected. We have no server.

C.      COMMIT 25: Hack FT runner to be able to test staging".

D.      Found my old domain name: beethovenkawaski.com, administered through google domains.

E.      Set up an account on Digital Ocean.

F.      Generated my own ssh key locally.

G.      Created a server ("droplet") on Digital Ocean, attaching the ssh key. (ipv4 of droplet is 159.89.44.252)

H.      Attached the google domain to the server.

I.      Successfully accessed the server via ssh from the terminal.

J.      Generated the account elspeth. Password can be found on LastPass under elspeth@159.89.44.252

K.      Linked ssh key to elspeth and granted elspeth superuser status.

L.      Erased auto-generated root domain and set up apex domains for superlists and superlists-staging. 

E.      Installed Python3.6 and venv on server via the deadsnakes repository.

F.      Installed git on the server. (It was already installed)

G.      Loaded code of this project onto github.

H.      Cloned git from github onto server.

I.      Attempt to run the server failed because Django is not installed on the server.

J.      File requirements.txt created locally containing the text "django==1.11", and added it to git.

K.      COMMIT 23: "Add requirements.txt for virtualenv"

L.      git pushed from local, and git pulled from server.

M.      Set up a virtualenv in the superlists-staging file.

N.      Successfully installed Django on the server, by pip installing (-r) from the requirements.txt file.

O.      Successfully launched the server for the first time.

P.      Functional tests failed because the local bash could not find the website we requested.
        In the code of the attempt, we defined the  STAGING_SERVER variable as our website. We
        also used the --failfast option to manage.py test. This causes the tests to clean up
        and close as soon as the first fail occurs.

Q.      We have pointed Django to our website. We have been running Django on the local host,
        and specified port 8000 in our project code. This causes no problems. But websites are typically run on port
        80, and that is where the functional tests are looking, now that we specified an external website.

R.      Functional tests run again, specifically pointing at port 8000 on the site. The tests fail again for
        the exact same reason.

S.      Attempted a BASH curl (from local bash) on the superlists-staging subdomain. Connection refused.

T.      Attempted to reach the same site directly through Firefox. Connection could not be established.

U.      Performed a BASH curl from the server (using localhost:8000). Success: the contents of the base
        HTML template are printed to the screen.

V.      It turns out that Django's development server is figured to listen in on //127.0.0.1:8000, the
    Django to listen on all addresses). Server starts without a hitch.

X.      From the server, curl localhost:8000 works just as before.

Y.      curl from laptap is successful (YES!)
xs
Z.      Attempt to run functional tests fails. Firefox launches, but no page is loaded; not even an
        error page. On server there is an error message that the HTTP_HOST header is invalid

AA.     Added the address of my project to the ALLOWED_HOSTS variable of settings.

AB.     COMMIT 23A. "Address of my project added to ALLOWED_HOSTS"

AC.     Attempt to run Functional Tests had the same results.

AD.     Actually, this error was very similar to the error the book predicted next, but not identical.
        In the book, the server caught the error and displayed it. However, this was not the case
        for my trial. Instead of adding the my site to the allowed host, I used the wildcard *, as
        specified in the book.

AE.     COMMIT 24: "hack ALLOWED_HOSTS to be *" Performed a push and pull.

AF.     Exited and relaunched the server. Server launched as expected.

AG.     curl from the server was successful.

AH.     curl from the laptop was successful.

AI.     Going through Firefox (superlists-staging.beethovenkawasaki.com:8000) was successful: the page
        loaded and the appearance was as expected.

AJ.     Functional tests fail because the table was not found.

AK.     Performed migrate on the server, and restart the server.

AL.     Functional tests passed.

CHAPTER 10: GETTING TO A PRODUCTION-READY DEPLOYMENT

A.      While it is great that our project works on a real-life webpage, it is not really ready
        for prime time. There are several problems.
        (1). Our to-list is presented on port 8000. But people doing everyday web work will be
        automatically directed to port 80.
        (2). The Django development server was not intended for real-life web use. It cannot
        handle the demands and volume of real web-traffic. We will be using the Nginx web server
        and the Gunicorn Python/WSGI server.
        (3). While DEBUG=True is good for development, it is strongly advised to have this set
        to False in production.
        (4). ALLOWED_HOSTS is currently a hack. We want it to allow only the hosts we specify.
        (5). We want our SECRET_KEY to be unique.
        (6). We don't want to ssh in to our server to start the site. We need to write a Systemd
             config file that allows for automatic boot/reboot of the server.

B.      Installed nginx on server. nginx started with systemctl start nginx.

C.      Went directly to the website (without the 8000 port). The nginx welcome page shows up.

D.      Functional tests fail. The tests find the nginx welcome page, and not the expected
        To-do list.

E.      Created a config file on server /etc/nginx/available-sites/superlists-staging.beethovenkawasaki.com
        
F.      Created a symbolic link in sites-enabled to the site file in available-sites. Removed the default
        file in sites-enabled. Restarted nginx and the server.

G.      Functional tests passed.

H.      Installed gunicorn on the server (it was already installed) Also upgraded pip.

I.      We tell gunicorn how to access the WSGI server by using the function "application",
        pointing to the superlists.wsgi file. This appears to run the site on the server.

J.      Functional tests fail because the formatting information was not found. (the static files.)

K.      While Django automatically serves up static files, gunicorn does not. We can use nginx for
        that.

L.      Used collectstatic to gather static files for the server.

M.      Altered the file /etc/nginx/sites-available/$SITENAME to include the location of the static files.

        NOTE: To do this on emacs, we use TRAMP. Here is the way it is done.
        1.    Use the key combination for opening a file, namely C-X C-F.
        2.    Backspace until you are in the root directory.
        3.    Enter /ssh:user@server|sudo:server:/desired/file/path
        4.    The first time you do this, you are asked for the password.
              After you enter it correctly, you will be presented with the option
              to save this password. If you select y, you will never need
              to enter the password again for this particular account.

N.      Restarted nginx like this: sudo systemctil reload nginx
O.      Moved to the /sites/superlists-staging.beethovenkawasaki.com folder and started gunicorn server like this:
        ./virtualenv/bin/gunicorn superlists.wsgi:application

P.      Ran the browser, and the site has the expected appearance.

Q.      Functional tests passed.
        NOTE: The new way of running functional tests is this:

        STAGING_SERVER=staging-server-name.sitename.com python manage.py test functional_tests --failfast
        The failfast option causes the testing to cease at the first failure.

R.      We will eventually be going to a production server. We want to be able to use the staging server
        and the functional server. They cannot both share the same port. We do not wish to arbitrarily assign
        two different ports. Instead, we will use a unix socket.
        We alter the sites-available file for our staging site so that the proxy_pass under the second
        location entry reads as follows:
        http://unix:/tmp/our-staging-site-name.com.socket;

S.      We restart the Gunicorn server, telling it to listen in on the socket instead of the default port.

T.      Functional tests pass.

U.      To have a production-ready site, we need to make a few changes to our current setup. These are:
        1. Get rid of the hack of the ALLOWED_HOSTS variable. The current wildcard entry is not secure.
        We want it only to match the site that we plan to serve on.

        2. The DEBUG mode is set to True. This was useful for the development and staging stages, but
        is insecure for the production site. This needs to be changed.

        3. The SECRET_KEY is used by Django. We do not want the server to have the same secret key as our
        local code. We need to generate a new secret key.

V.      We go to our local superlists/settings.py file and make these changes. We accomplish this by
        branching and environment variables.

W.      COMMIT 25: "Use env vars for prod settings DEBUG, ALLOWED_HOSTS, SECRET_KEY"

Y.      Used export to temporarily set the variables DJANGO_DEBUG_FALSE DJANGO_SECRET_KEY

Z.      Functional tests failed because "To-Do" was not found on the webpage. A look on the browser
        shows a bad request 400.

AA.     Nginx by default strips out the Host headers, and it appears that the page comes from localhost.
        We add the proxy_set_header directive to the sites-available/SITENAME file.

AB.     Functional tests pass.

AC.     We have been entering environment variables directly in the shell. But this is a pain in the ass.
        We will have a file called .env to store them. First we add this to .gitignore.

AD.     COMMIT 26: "gitignore .env file"

AE.     Added the .env file to the server. Added the environment variables for DJANGO_DEBUG_FALSE,
        SITENAME to .env. Also added a new secret key generated by Python3.6 random.

AF.     Functional tests pass.

AG.     We set up a config file using Systemd so that Gunicorn starts up automatically if there is
        a crash. And we run a few shell commands to get the server to recognize this config file.

AH.     Functional tests pass.

AI.     We install Gunicorn onto our local machine. Then we add it to the list of .requirements

AJ.     COMMIT #27: "Add gunicorn to virtualenv requirements."

AK.     On our local machine, we added a folder called deploy_tools. In this folder we created
        a file called nginx.template.conf. This contains the information from the sites-available file
        under the server /etc/bin/nginx/sites-available/SITENAME file.

AL      On our local machine, we added a file deploy_tools/gunicorn-systemd.template.service. This contains
        a copy of the code in the server /etc/systemd/system/gunicord-SITENAME.service file.

AM.     In the same folder, we added a text provisioning notes file.

AN.     COMMIT #28: "Notes and template config files for provisioning"

CHAPTER 11: AUTOMATING DEPLOYMENT WITH FABRIC

A.      We install Fabric on the laptop. (pip install fabric3)

B.      We write a new file deploy_tools/fabfile.py. This file contains commands for Fabric to run
        when it deploys the site. It includes a function that deploys the website, and references
        other functions we will write.

C.      Then we add a function to the file that commits the deployment to git.

D.      Next we add a function that updates virtualenv.

E.      Next we a function to create a .env script.

F.      Next we write a single-command function that updates the static files.

G.      Finally, a single-command function that updates the database.

H.      We do a git push.

I.      We try out our file by deploying to the staging server. This works.

J.      We deploy to the production server. This works as well.

K.      On the server, we do a git pull. Then we use the bash command sed (stream editing) and pipes
        to create a new file for the real site that contains the nginx.

L.      Just as before, we create a link in the sites-enabled folder to the appropriate file in sites-available folder.

M.      We use sed to pull the systemd (unicorn) config file in, too.

N.      We start all services, and the site appears correctly on the production server.

O.      COMMIT #29: "Add a fabfile for automated deploys"

P.      We add a git tag to keep a record of what's currently live on the server.

CHAPTER 12: SPLITTING OUR TESTS INTO MULTIPLE FILES, AND A GENERIC WAIT HELPER

A.      We decide that we want our site to clean up careless mistakes by users. The first of these
        is preventing users from entering blank todo items.

B.      We write up the script for the user experience on a new test in the functional tests:
        test_cannot_add_empty_list_items.

C.      We realize that our functional tests are getting really crowded. We'd like to divide
        the functional tests up into separate files. We want each file to test only one thing.
        In addition, we want a base test case, which the other tests can inherit from.

D.      We would like to be able to skip certain tests during our work. We add the following import
        to the top of the file: from unittest import skip. Then we mark our newest functional test
        method with a skip decorator.

E.      We run the functional tests (the new one is skipped) and they pass.

F.      We begin splitting up our functional tests into separate classes, still within one file.
        We create a new class: FunctionalTest(StaticLiveServerTestCase). We move the following methods
        to this new class: setUp, tearDown, wait_for_row_in_list_table. Then we change the NewVisitorTest
        so that it inherits only from FunctionalTest. Then we create another new class LayoutAndStylingTest(FunctionalTest).
        This will have the test_layout_and_styling method. And we add a third new class ItemValidationTest(FunctionalTest).
        This gets our new method. All other test methods stay within our class NewVisitorTest.

G.      We run our functional tests and they still pass.

H.      We use git mv to change the name of the functional_tests/tests.py to functional_tests/base.py.
        Then we make three copies of the file in the same folder, with new names, reflecting the names
        of the test classes we want each file to contain.

I.      We change the base file. We remove the import of skip. We remove the import
        selenium keys import. Then we get rid of all the code after the first class.

J.      We change the test_simple_list_creation file. We add the import from .base import FunctionalTest. We
        keep the first two imports from webdriver. We get rid of the rest. Then we get rid of the MAX_WAIT variable.
        And we get rid of all classes except NewVisitorTest.

K.      We change the test_layout_and_styling.py file. We retain only the Keys import. And we add the import of
        FunctionalTest. Then we get rid of all the code except the class LayoutAndStylingTest.

L.      We change the test_list_item_validation.py file. We get rid of all imports except the import to Keys
        and the skip import. Then we add the FunctionalTest import. We get rid of all code except the
        class ItemValidationTest.

M.      Functional tests run successfully.

N.      We remove the skip decorator from the test_list_item_validation file (above the sole method in the sole class).

O.      We now run the single test like this: python manage.py test functional_tests.test_list_item_validation.
        We have an expected failure: The AssertionError: write me! Because we have not written a test.

P.      COMMIT #30: "Moved Fts into their own individual files."

Q.      We begin fleshing out the new functional test. We have it search for a particular error.

R.      We realize that we will need an explicit wait, for this test, and we decide to design a new one. We
        temporarily remove the error checking code, and call a new method on self called wait_for. We
        haven't created this method yet. The argument is a lambda function on our original error checking code.

S.      We go back to the base file, and copy the wait_for_row_in_list_table to wait_for, so that we have
        two of them. Then rename the second one wait_for(self, fn). We change the try: part of the code
        so that it simply says return fn(). We now can toss this helper any function to wait for, and it
        will do so.

T.      Functional tests fail because we have asked the error checker to check for an element called .has-error.
        This element does not exist yet.

U.      COMMIT #31 "Added generic wait helper function."

V.      Now it's time to break up our unit tests into separate files as well.

W.      We make a new directory lists/tests. We create a new file lists/tests/__init__.py. We
        move lists/tests.py to lists/tests/test_all.py. Then we git add lists/tests.

X.      Unit tests pass.

Y.      COMMIT #32: "Move unit tests into a folder with single file"

Z.      We rename test_all.py to test_views.py. We copy this file to a file with the name test_models.py.

AA.     We edit list_models.py so that it contains only the class ListAndItemModelsTest(TestCase).

AB.     We edit list_views.py by removing only the ListAndItemModelsTest(TestCase).

AC.     Unit tests pass.

AD.     COMMIT #33: "Split out unit tests into two files."

CHAPTER 13: VALIDATION AT THE DATABASE LAYER

A.      We run the single functional validation test, and it fails the same way as before.
        We have not created an element called .has-error.

B.      We can do validation on the client side or the server side. Server side is safer,
        so we will go with that. In the server side, we can do validation at the model
        level or at the forms level. We are choosing the model level, because it is closer
        to the level of the actual database.

C.      To the top of the test_models.py file, we add a new import
        from django.core.exceptions import ValidationError.
        We add a new method to the sole class in test_models called
        test_cannot_save_empty_list_items(self). This test creates a new list item that is blank,
        and we use the Django assertRaises to check that trying to save the blank item
        raises a ValidationError.

D.      As expected, the unit tests fail because we have not set up a mechanism to throw a
        ValidationError.

E.      This is related to a Django quirk. The Django variable TextField defaults to blank=False.
        Therefore, it should throw a ValidationError automatically when we try to save a blank
        text to the database. However, our database, SQLite doesn't allow constraints on blank
        cells. So Django silently lets this error pass. Running migrations won't help, because
        Django knows that SQLite will not allow constraints on blank cells. However, a Django
        function full_clean will run validations manually, and this may be the solution to our
        problem. We add item.full_clean() at the bottom of the last block in our new method.

F.      Unit tests pass. It worked.

G.      We want an error message to appear to the user. We achieve this by adding some code to
        the lists/templates/base.html file.

H.      Next we add a new unit test to test_views.py called
        test_validation_errors_are_sent_back_to_home_page_template(self). It generates a new list
        with a blank item. It tests to make sure that the response code status is 200 (normal),
        that the template used is the home template, and that the page contains the error
        message we want.

I.      We also notice that we've hard-coded the name of a URL into this code. We have a lot
        of these floating around are tests, which means we are violating DRY. We will look into
        this after we get everything working again.

J.      The unit tests fail because the status code is 302 and not 200. This is a type of redirect response.
        It is not what we want.

K.      We changed the new_list function in views.py so that it uses the full_clean() function.

L.      The unit tests fail, indicating that the attempt to enter a blank to-do entry raised
        an error, and this has reached the template. This is what we want.

M.      We go to the views, and place the item.full_clean() in a try block. If a ValidationError is caught,
        it will simply pass. We also import the ValidationError.

N.      Unit tests fail, because there is a redirect instead of a straight code 200, as before.

O.      We change the return on the view from a redirect to a rendering of the request to the
        home_html template.

P.      Unit tests fail because it can't find the error message on the web page.

Q.      We change the except block in lists/views.py so that it posts the error with the wording we wish.

R.      Unit tests fail for the same reason.

S.      We alter lists/tests/test_views.py so that it prints out the html of the webpage that is rendered.
        We do this as a debugging technique.

T.      We find that Django is automatically escaping the apostrophe in the error message.

U.      We add an from "djanto.utils.html import escape" to test_views.py. Then we wrap the desired error
        message in an escape.

V.      Unit tests pass.

W.      We realize that, although we are getting the appropriate error message for an attempt to add a
        blank item to the list, we haven't checked to make sure that the item is kept out of the database.

X.      We add a new test to the unit tests: test_invalid_list_items_arent_saved(self). This tests to
        make sure no item was added to the database if the empty item errror is raised.

Y.      Unit tests fail because, as expected, the empty items are being saved to the database.

Z.      We alter lists/views.py so that the try block also contains the save() function. The
        except block now begins with a delete() function, to remove the newly added empty item.

AA.     Unit tests pass.

AB.     Functional tests fail, but more tests pass than before. Specifically, the functional tests
        are failing because selenium cannot find an element called .has-error

AC.     COMMIT #34: "Adjust new list view to do model validation"

AD.     The next thing to do is to put all of our POST requests into the same file. This breaks with RESTful
        programming. But it is in better alignment with standard Django procedure.

AE.     We alther lists/templates/list.html so that the form will have a different target.

AF.     Functional tests fail. We have broken the POST request system, so we have a failure in submitting
        items and saving them, as well as the lack of .has-error.

AG.     We move test_can_save_a_POST_request_to_an_existing_list to the ListViewTest class. We change the
        post site to /lists/{correct_list.id}/. We also change the name of the test_redirects_to_list_view
        to test_POST_redirects_to_list_view. We change the post site in the same way, and move it to
        the ListViewTest class. We get rid of the class NewItemTest.

AH.     Unit tests fail because there was a redirect instead of a standard code 200. In addition, the
        items are not being saved to the list.

AI.     We change the views so they can deal with two different kinds of requests.

AJ.     Unit tests pass.

AK.     Since we no longer need it, we delete the add_item view.

AL.     Unit tests fail. Our url regex is expecting the add_item view.

AM.     We remove the url regex that references the add_item view.

AN.     Unit tests pass.

AO.     Functional tests fail at the same place.

AP.     COMMIT #35: "Refactor list view to handle new item POSTS"

AQ.     Now, we want to make sure that blank items cannot be added to an already started list.

AR.     we write test_validation_errors_end_up_on_lists_page(self) to the ListViewTest.

AS.     Unit tests fail because the view does not currently perform any validation. This
        is doing a redirect instead of giving the 200 code.

AT.     We revamp the view_list method so that it closely resembles the try block we wrote before.

AU.     Unit tests pass.

AV.     Functional tests pass.

AW.     COMMIT #35: "Enforce model validation in list view."

AY.     Next, we want to get rid of all of our hard-coded Urls.

AZ.     We change the home template so that the block form action calls {% url 'new_list' %}

BA.     Unit tests pass.

BB.     We change the list template so that the block form action calls {% url 'view_list' list.id %}

BC.     Unit tests pass.

BD.     COMMIT #36: "Refactor hard-coded URLs out of templates"

BE.     Now it's time to refactor views so that there is not duplicate code.

BF.     We add another test method to test_models.py: test_get_absolute_url.

BG.     Unit tests fail, because List has not atteribute 'get_absolute_url'.

BH.     We go the models file. We add from django.core.urlresolvers import reverse.

BI.     We write code that provides an absolute_url to the List object.

BJ.     We go to views and change the final redirect of new_list to list_.

BK.     Unit tests pass.

BL.     We alter the view_list so that the redirect in the try block is to list_.

BM.     Unit tests pass.

BN.     Functional tests pass.

BO.     COMMIT #37: "Use get_absolute_url on List model to DRY urls in views"

CHAPTER 14: A SIMPLE FORM

A.      The views are too complex. We need to move some of the logic into forms.

B.      We create a new file lists/tests/test_forms.py. We write a class ItemFormTest
        and it includes one method: test_form_renders_item_text_imput to test our form,
        which does not exist yet. We use form.as_p which renders the form as HTML.

C.      We create a rudimentary form file.

D.      Unit tests fail because the form does not have the right structure.

E.      We change the ItemFormTest to containing a single test
        test_form_item_input_has_placeholder_and_css_classes.

F.      Unit tests fail because the placeholder code is not found in the form.

G.      We adjust the ItemForm so that it contains the placeholder.

H.      Unit tests fail because the css code does not appear in the forms.

I.      We add the class form.field.

J.      Unit tests pass.

K.      We want validation to work on the form version.

L.      We introduce the attribute Meta, which allows us to convert a view into a form.

M.      Unit test fails, with a similar error as before. But now, we've lost our
        placeholder and css fields, and the field that should be 'item_text' is 'text'.

O.      We add a widget to our Meta class, which specifies the placeholder and css class
        information we need.

P.      Unit tests pass.

Q.      We wish to see if the vadiation works in the form. We add a new test
        in test_forms test_form_validation_for_blank_items.

R.      We get an error, because, fortunately, the site is not saving blank items to
        the database.

S.      Now the next step is to catch the condition before it raises the exception.
        We add code to the new test which asserts that the form is invalid and
        checks that the error text on the form is what we want.

T.      Unit tests fail, as expected, because we have not told the form to supply the
        error message.

U.      We need to change our Meta variable, so that we get to use our own error message
        instead of the default.

V.      Unit tests pass.

W.      But we want to make our error message a constant variable. We change the code to reflect that.

X.      Unit tests pass.

Y.      We change the test_forms file to make use of the new constant.

Z.      Unit tests pass.

AA.     COMMIT 38: "new form for list items"

AB.     Now we will get our form to work with our views. We start by writing a new unit test to veriy
        that we're using the right kind of form. test_home_page_uses_item_form is added to the HomePageTest
        class.

AC.     Unit tests fail, because we have specified a context of 'form' which the test cannot find.

AD.     We change the home_page return in our views so that it uses ItemForm, and gives it the
        name 'form'.

AE.     Next, we add it to the base.html template.

AF.     Unit tests pass.

AG.     Functional tests fail miserably. By altering our base HTML, we got rid of variables names
        that the functional tests rely on. We need to refactor so that these variables are no
        longer used.

AH.     COMMIT #39: "Use new form in home_page, simplify tests, NB breaks stuff"

AI.     Now we begin our refactoring. We make a new helper method in our functional tests
        get_item_input_box, and then we go to all places in our files where we have id_new_item
        and replace it with the name of this function.

AJ.     We search through our lists folder using grep to find all occurences of id_new_item.
        We replace each occurence with id_text. Then we do the same for item_text and we
        replace each occurence with 'text'.

AK.     Unit tests pass.


AL.     All four functional tests return errors. The tests are still looking for 'id_text'. After we
        submit an item, the input box disappears from the web page. If there is a validation error,
        we are not passing a form to the home.html template.

AM.     COMMIT #40: "rename all item input ids and names. still broken"

AN.     We go to lists/tests/test_views.py. We see first, that the test is really testing too many
        things. So we are going to split out two assertions. And we need to add a new assertion:
        that we are passing our form object to the template if there is a validation error.
        We can also get rid of the hard-coded string of the error message and import the constant.

AO.     Unit tests fail because test_for_invalid_input_passes_form_to_template cannot find a dictionary
        key 'form'.

AP.     We alter view.py.new_list. We have a variable called "form" which contains an ItemForm, with
        data gleaned from a request.POST. If the form.is_valid(), we post the form to the site and
        redirect to the list. If not, we redirect to home.

AQ.     Unit tests fail because it could not find the error message on the page when an error situation
        was created. This is because we are not yet using the form to display error messages.

AR.     We change the base.html template so that errors are caught and displayed from the form.

AS.     Unit tests fail because we have changed the way errors are displayed in all templates.
        This means the error we manually feed to view_list is overwritten.

AT.     We write a new unit test test_displays_item_form.

AU.     Unit tests fail, as expected, and it's because there is no key found with the name "'form'"

AV.     We fix this minimally by going to views.py, and before the final return, adding
        form = ItemForm. And the render dictionary now has an additional entry: "form": form

AW.     We want the form errors to also appear in the second view. We will split up the
        test_validation_errors_end_up_on_lists_page into several tests. First we write a helper method
        post_invalid_input, to avoid code duplication.

AX.     Unit tests fail for only one reason: The error message is not appearing in the response.

AY.     We rewrite the view.

AZ.     Unit tests pass.

BA.     Functional tests returned error on second test. The test was unable to find the element .has-error.

BB.     The "problem" is that, with HTML5, Django automatically prevents invalid input. Therefore, a blank
        item cannot be submitted. So the error that we intended never appears for the test to see.

BC.     This is serendipitous. We don't need our check for empty items. The browser does it automatically.
        We rewrite our functional tests to test that this is occurring at all the necessary points.

BD.     Functional tests pass.

BE.     COMMIT #41: "use form in all views, back to working state."

BF.     The previous might have seemed like a big waste of time. We spent all the time creating an error message,
        and getting the message to percolate up through the code to the user. However, this was never needed
        in our current use case. We should not be worried. First of all, not all browsers could handle
        HTML5 at the time of this writing, especially Safari. Second of all, we will want to expand our
        validation soon in ways that HTML5 can't handle. We already have the machinery set up to do this.
        Finally, even if the first two were not true, we must realize that going down blind alleys is
        part of coding. It will happen now and then. We should expect them on occasion and not beat ourselves
        up when we discover them.

BG.     We need to clean up a little. As it stands now, the forms are not actually saving items to the database.
        We write a test for this in test_forms.py

BH.     Unit tests fail because we haven't specified which list the the form's save method should send the data to.

BI.     We revise the test to create a new list, make a form with some fanciful text, assign the results
        of form.save(for_list=list_), and run assertions that the new item appears first on the list,
        that it's contents are what we entered, and that the list matches the list we created.

BJ.     unit tests fail because the save() function did not recognize the argument 'for_list'

BK.     In our forms.py.ItemForm, we create a custom save function.

BL.     Unit tests pass.

BM.     Time to refactor the views. We refactor new_list

BN.     Unit tests pass.

BO.     Refactor view_list

BP.     Unit tests pass.

BQ.     Functional tests pass.

CHAPTER 15: MORE ADVANCED FORMS

A.      Now we are going to add validation code to prevent duplicate items in the list.

B.      We add a new test in our functional tests to address this.

C.      As expected, the functional tests fail because we have not written error-handling code
        to address this situation. We also are reminded that the first test in this file passed again.
        We can run only method at a time when we do a test run by python manage.py test APP.FILE.CLASS.METHOD

D.      We ran just the functional test that failed, and of course, it failed again.

E.      We now want to write a new unit test in the test_models to make sure that duplicate items in the same
        list raise an error.

F.      And we write another unit test to make sure that duplicate items CAN be saved to DIFFERENT lists.

G.      Of course, the unit tests fail because we have not added code to raise a ValidationError if there
        is a duplicate list item. This is the wrong solution.

H.      We go to our models, and adjust the definition of text: the models.TextField now includes the
        keyword argument unique=True.

I.      The unit tests fail, now because it won't allow us to save a duplicate item to a different list.
        We have written a test against developer stupidity. In general, these should be avoided. We can
        trust that we will not intentionally do anything stupid. However, we cannot trust that we will
        not accidentally do something stupid. It is ok to write tests that check for accidental stupidity.

J.      We go to models, and use the class Meta, as before, to make a constraint that a duplicate item
        cannot be saved to the SAME list. We get rid of the stupid keyword argument, while we are at it.

K.      Unit tests pass.

L.      Now, in the book, there was an error at this point. The author said that this error might not appear.
        It indeed did not appear for me. He continues as if the error did appear, and writes more tests.
        We will do as the author did, and add tests. The problem that the author saw was that the uniqueness
        criterion had altered the default ordering of entries in the lists. 

M.      We add a test for list ordering in test_models.py

N.      Now the unit tests fail. But the error message is opaque.

O.      We write another unit test of the string representation. Normally we would not want to introduce
        a new unit test while another is still failing. But if the unit tests are simple, and doing so
        helps to resolve the problem you are seeing, than this is acceptable.

P.      The string representation is not the text we entered, but the string representation of the
        type of the object. We go to models.py and add a magic method overriding str.

R.      The unit test for the string representation now passes. But the unit test for ordering
        still fails, and we can see more clearly why. The query set for the list is not the
        same thing as the list itself.

S.      In models.py, we add the line ordering = ('id',) to the Meta class of the Item class.

T.      This fixed the original error in the author's case, but the queryset != list error
        remained, as it remains for me.

U.      We change the order test so that it casts Item.objects.all() to a list.

V.      Unit tests pass.

W.      Now we greatly simplify our tests, while still testing for the same things.

X.      Next, we split the test_models.py to two classes. One tests for Item, and the other
        tests for List.

Y.      Unit tests pass.

Z.      When we run makemigrations at this point, we notice that Django wants to add our new
        duplicate constraint directly to the database, instead of allowing it to remain in
        higher level code.

AA.     We change our duplicates test to do a .save instead of a .full_clean.

AB.     And now we see that an error bubbles up from the database. It is a different
        kind of error from the one we want to display.

AC.     We revert to the .full_clean.

AD.     Unit tests pass.

AE.     COMMIT #42: "Implement duplicate item validation at model layer"

AF.     We want to put this form to work in our view. We go to test_views.py and add imports from
        lists.forms of DUPLICATE_ITEM_ERROR and ExistingListItemForm. We remove the skip decorator
        above test_duplicate_item_valudiation_errors_end_up_on_lists_page.
        We replace the hard-coded error message of expected error with the DUPLICATE_ITEM_ERROR

AG.     Unit tests fail because the integrity error is bubbling up from the database.

AH.     We add test_displays_item_form to the ListViewTest of test_views. And we modify
        test_for_invalid_input_passes_form_to_template to that these make use of the
        the new forms.

AI.     The unit tests fail because we have not yet adjusted the view to account for the form.

AJ.     We adjust the views so they make use of ExistingListItemForm.

AK.     Unit tests fail because we are the new custom save() method is missing the for_list
        attribute. We don't need this in the ExistingListItemForm.

AL.     We write a new unit test to to check the saving goes ok.

AM.     And then we define a new save method for the ExistingListForm that inherits from the grandparent
        method.

AN.     Unit tests pass.

AO.     Functional tests pass.

AP.     COMMIT #43: "Brought forms up to views."

CHAPTER 16: DIPPING OUR TOES, VERY TENTATIVELY, INTO JAVASCRIPT

A.      We want our duplicate item errors to vanish as soon as the client starts
        fixing the problem. To do this, we need to use some JavaScript.

B.      We add a new functional test to the ItemValidationTest class.

C.      Functional test fails as expected because we haven't written any code to remove the
        error message once the user starts correcting herself.

D.      Three strikes and a refactor. It is time to get rid of duplicate code. We have three
        places where we are looking for an error element by CSS. We can move that to a
        helper function. And we replace the boilerplate code at three points within the
        class to calls to the helper function.

E.      Functional tests fail, as expected, in the same way as before the refactor.

F.      COMMIT #44: "First version of Functional Test for removing error message when user begins fixing problem."

G.      Since we are going to be working with JavaScript, we will need a JavaScript testing framework. The author
        decided to go with Qunit, as it is simple, and works somewhat like selenium. We have created a new directory
        lists/static/tests. Into that directory, we placed the current versions of the Qunit css and js code.

H.      In the same directory, we create a file tests.html. We write a up the file, which includes a smoke test.

L.      We open the browser, and simply load the html file into the browser. The page displays a header that says
        JavaScript tests. It states that the smoke test was run and passed.

M.      To see a deliberate failure, we change the arguments of the smoke test and reload the page.
        We see a message for a failing test, as expected.

N.      We download the latest copy of Jquery and put it into the lists/static directory.

O.      We write a new smoke test in tests.html. This tests that .has-error is visible, then makes
        it invisible, and tests to see if it is invisible. The test relies on both jquery and qunit.

P.      We refresh the browser and the test passes.

Q.      To see how the fixtures work, we duplicate the test within the document, changing the name of
        the second test slightly.

R.      This time the test fails. Since we've hidden the .has-error class in the page, the assert
        visible does not pass.

S.      We need a clean-up function, and the qunit-fixture div does this. We move the form in there.

T.      Both smoke tests pass.

U.      We go back to having one test, and begin writing it to handle our particular case:
        errors should be hidden on keypress.

V.      The test fails as expected.

W.      To tests.html, we add another script src: list.js, which will reside in the parent directory.

X.      We create the file list.js in the parent directory and write the minimal js code to get the
        test to pass. We just tell the .has-error element to hide.

Y.      js Unit test passes as expected.

Z.      Now, errors shouldn't be hidden if there is no keypress, so we create another js unit test
        to test for this.

AA.     js Unit tests fail as expected.

AB.     We change our list.js file so that it only hides the error if a key press is detected.

AC.     But js Unit tests fail the same way again.

AD.     We decide to add some console logs to our testing and the js file to see why this is failing.

AE.     Using Ctrl+Shift+I we can see the element inspection. It tells us that list.js is loaded first,
        then QUnit tests file loads, then each test is run. The problem is that each test has been sandboxed,
        so any input that was present for the first test will be gone by the time the second test is run.
        We need to be able control the execution time better.

AF.     We add an initialize variable to our js file that wraps the rest of our code. Then we call
        initialize with each test.

AG.     js unit tests pass.

AH.     We remove the console logs from the js file and the tests.

AI.     Now it's time to actually use this logic in for real. We add html and js code into lists/templates/base.html
        the pulls in the JQuery and our script.

AJ.     The Functional test that addresses this concern passes.

AK.     COMMIT #45: "add jquery, qunit tests, list.js with keypress listeners"

AL.     We decide that our initialize() function has a name that is too common, and could likely
        cause collisions if other code is imported. We decide to set up a namespace in our js doc.
        And we change our js unit tests accordingly.

AM.     Although we have placed our js script on the template at the bottom of the body, we
        shouldn't assume that this will always load last. We need to wrap it in the Jquery
        onload function to make sure the whole page loads before the test is executed.

AN.     The relevent functional test passes.

AO.     COMMIT #45: "refactored the initialize() function so that it is part of a namespace in the
        list.js file, and made the necessary changes in the tests.html and base.html documents."

CHAPTER 17: DEPLOYING OUR NEW CODE

A.      It is time to deploy all our new code to the real servers.

B.      We do a git push. I needed to increase the size of the git global http.postBuffer to do this.

C.      Used fab to deploy to superlists-staging

D.      On the elspeth server, restarted gunicorn for the staging site.

E.      Ran functional tests against staging site. They all passed.

F.      Used fab to deploy to superlists.

G.      On the elspeth server, restarted gunicorn for the public site.

H.      Ran functional tests against production site. They all passed.

I.      GIT TAG #2. git tag -f LIVE; assigned the current time to the variable TAG with
        export TAG=`date +DEPLOYED-%F/%H%M`; git tag $TAG; git push -f origin LIVE $TAG

PART III. MORE ADVANCED TOPICS IN TESTING

CHAPTER 18. USER AUTHENTICATION, SPIKING, AND DE-SPIKING

A.      Our to-do list is nice, but people have been complaining that they are always losing their lists.
        They can't remember the URL we generate for them. It would be nice to have user authentication, so
        that the person doesn't need to remember the URL. Passwords are complicated and a security nightmare
        to store. Other members of user-authentication often rely on membership in other sites, which
        gives these companies too much information about its users. One neat solution is to use Passwordless.
        For this system, every time someone wants to log in, we generate a random URL and send it to their
        email address. They they log into their email and access their list through the random URL.

B.      Spiking: this is a new TDD technique for us. We are not sure how something works, or we want to experiment
        with a new technology before we use it in our project. We temporarily set aside the TDD loops and quickly
        build a very simple app that gives us insight into the way the technology works. Once we have insight
        into the technology, we can then resume our original project and the TDD loops with added insight, and
        hopefully, new tools.

C.      We create a new branch in our git, so that we can experiment, yet keep the original code that works
        well right now.
        The code for that is
        git checkout -b NAME-OF-BRANCH
        Here, we use passwordless-spike for NAME-OF-BRANCH

D.      First, we go to base.html and add html code to allow users to enter an email address into the navbar, and
        a logout link for users who are already authenticated.

E.      Now, our goal is to store user email addresses. When a user types their email address into the site,
        a random URL will be generated and stored in a database keyed to the user's email address. Then the
        URL is sent to the user's email address. The list that the user has stored will be available at this
        address. The user simply needs to go to that site, and he will have his list.

F.      We set up a new app to provide our database. python manage.py startapp accounts

G.      We go to superlists/urls.py and add a url pattern for our accounts.

H.      We create the file accounts/urls.py. Imports: from django.conf.urls import url; from accounts import views.
        We create the variable urlpatterns, which contains one email pattern containing send_email and send_login_email.

I.      We go to accounts/views.py and write up a script sends a login email complete with a generated url.

J.      We create the directory accounts/templates. And make a file accounts/templates/login_email_sent.html.
        We create a template that displays the message Email sent, and a request that the user check his email.

K.      We go to superlists/setting.py and add variables defining the attributes of our server email address.
        We can choose any host we like as lon as it has smtp. I set up a new gmail account for this purpose
        beethovenkawasaki1770@gmail.com. I leave the two-step authentication off. I also change the settings
        to allow less secure apps.

L.      I export my email password to the variable EMAIL_PASSWORD in bash. This will be an environment variable,
        and we will have a different solution later. Be wary of an exclamation mark in your password. Bash
        interprets this functionally, even though it is inside quotes. It needs to be escaped with a backslash.

M.      In accounts/models, we create a TOKEN model that links an email address with a unique ID.

N.      In the same file, we create a user model. It is very minimal.

O.      And we put in a list manager model.

P.      We go to accounts/views.py and add code to deal with a request from someone clicking the link on their email.

Q.      We create a file accounts/authentication.py that configures the Django configuration framework.

R.      We add a logout view.

S.      We add login and logout urls to the urls.py file.

T.      Go to the superlists/settings.py file and switch on the auth backend and our new accounts.

U.      Then we make migrations. And migrate.

V.      And the site works the way we intended.

W.      COMMIT #45a: "spiked in custom passwordless auth backend"

X.      Now we begin the de-spiking. The first thing is to write a functional test, but we
        stay on the spiking test.

Y.      The functional test passes.

Z.      Now it is time to get this functionality into our production code. We will revert
        to the version we saved prior to the branch. Then, we will add features one by
        one using tests.

AA.     First, we revert to the pre-branch code.
        git checkout [NAME-OF-MAIN_BRANCH] # switch back to main branch
        rm -rf accounts # remove any trace of spiked code
        git add functional_tests/test_login.py

AB.     COMMIT #46: "FT for login via email"

AC.     Functional test test_login failed because it was unable to locate an element with the name "email".

AD.     We go to lists/templates/base.html and use some of Bootstrap's built-in class for navigation bars.

AE.     Targeted functional test fails because the email box has no functionality.

AF.     We added a new variable to superlists/settings.py called LOGGING, with several nested specifications.
        This will allow us to keep track of everything that happens, and will post errors to the console
        through stderr.

AG.     We create an app called accounts.

AH.     COMMIT #47: "added the new app accounts"

AI.     In the accounts directory, we delete the test.py file. We create a directory called test. We add
        a Python init file into this directory. We also add a file called test_models.py. This contains
        one test class: UserModelTest, which contains one method: test_user_is_valid_with_email_only.

AJ.     This unit test fails because Django is expecting the user_name and pass_word fields, which we
        do not address.

AK.     We go to the accounts/models.py file and add a class defining a User, and define the variable
        email as the models.EmailField(). We then go to superlists/settings.py, and add 'accounts' to
        our installed_apps variable. We also add a new variable AUTH_USER_MODEL and set that equal to
        'accounts.User'

AL.     The unit test fails because there is no table with the name accounts_user.

AK.     We attempt to make migrations. But this fails because type User has no attribute REQUIRED_FIELDS

AL.     In the accounts/models.py file, in the class User, we add the variable REQUIRED_FIELDS and
        set it equal to [].

AM.     We attempt to make migrations. But this fails because type User has no attribute USERNAME_FIELD

AN.     We add another variable USERNAME_FIELD and set it to equal to 'email'.

AO.     We attempt to make migrations. But this fails because type User has no attribute is_anonymous.

AP.     We add another variable is_anonymous and set it to equal False.

AQ.     We attempt to make migrations. But this fails because type User has no attribute is_authenticated.

AQ.     We add anoter variable is_authenticated and set it to equal True.

AR.     We attempt to make migrations. But this fails. It says 'User.email' must be unique because it is
        named as the USERNAME_FIELD.

AS.     We change the definition of our email variable so that it is a unique email.

AT.     Attempt to make migrations succeeds.

AU.     Account unit test passes.

AV.     We wish to make this model even simpler. We can do so by getting rid of the auto-generated
        ID field. We can use our email addresses as the ID field. NOTE: a reader has indicated
        that in her business this very decision has caused years of headaches. It should therefore
        be avoided in practice.

AW.     We begin by writing a unit test that tests to make sure the email address is the primary key. (pk)

AX.     This unit test fails, as expected.

AY.     We go back to our models.py file and change the email definition. Previously, the sole argument
        was unique=True. We change that to primary_key=True.

AZ.     accounts unit tests pass.

BA.     We remove the previous migration with rm accounts/migrations/0001_initial.py. We makemigrations
        again (which succeeds).

BB.     acounts unit tests pass.

BC.     Now we want to build a simple token model. First, we go to test_models.py and add a new class:
        TokenModelTest. It contains a single method: test_links_user_with_autogenerated_uid(self)

BD.     accounts unit tests fail because it cannot import Token from accounts.models.

BE.     On my own, I create a class called Token(object) with pass for the code.

BF.     accounts unit tests fail because Token has no attribute 'objects'.

BG.     On my own, I make Token inherit from models.Model.

BH.     accounts unit tests fail because there is no such table accounts_token.

BI.     I makemigrations, which succeeds.

BJ.     The new unit test fails because 'email' is an invalid keyword argument for this function.

BK.     On my own, I define an __init__ method for Token. It has an email parameter, and sets self.email = email.

BL.     The new unit test fails because NoneType object has no attribute 'attname'

BM.     In the init method, I add a line that is self.attname = None

BN.     Same error.

BO.     I get rid of the __init__ method. Instead, I follow the author's lead. I add a variable email and
        set it to models.EmailField()

BP.     The new unit test fails because there is no column accounts_token.email in the database.

BQ.     We attempt to makemigrations, which fails because we are entering a non-nullable field.

BR.     In the new email variable, we specify the models.EmailField has the arugment
        default='noemail@example.com'

BS.     We makemigrations. It works.

BT.     The unit test fails because Token object has no attribute uid

BU.     We add another variable. uid = models.CharField(max_length=40) [this is from the book]

BV.     Unit test fails because the accounts_token.uid column does not exist.

BW.     In the book, definition for email did not include any defaults. We will revert to the previous
        migration, get rid of the uid line, and make the email definition our definition of models.EmailField()

BV.     We makemigrations, and are presented with the option of supplying a default value or hardwiring into
        our code. We provided one. 'no_email_provided@example.com'

BW.     Then we add back the uid defintion.

BX.     Unit test fails because the uid column is not found.

BY.     Make migrations again presents us with an option for a default. We use 'no_uid_available'.

BZ.     Unit test fails because the uids of the two login attempts were identical.

CA.     We add an import to uuid. We supply the method in the uid definition with
        another kwarg: default=uuid.uuid4

CB.     Unit test passes.

CHAPTER 19: USING MOCKS TO TEST EXTERNAL DEPENDENCIES OR REDUCE DUPLICATION

A.      We have been using a Django utility mail.outbox. This saves a lot of work and frustration.
        However, we wish to learn how to do mock tests. These (apparantly) are tests that
        probe the interaction of our probject with an outside API. Because this aspect of
        sendng emails is neatly handled by mail.outbox, we will want to forego using it
        now simply for pedagogical purposes.

B.      First, we need to get the basic structures set up. First we want to see that our
        new URL for sending the loin email should eventually redirect back to the home page.
        We start with a new unit test. We create accounts/tests/test_views and  add the class
        SendLoginEmailViewTest. It contains the method test_redirects_to_home_page

C.      We go to the superlists/urls file and add an accounts url specification with an
        include to accounts.views.

D.      We go to accounts/views, and, after adding a few imports, create a function called
        send_login_email.

E.      We create an urls.py file in accounts and specify a url pattern which will activate the
        send_login_email function.

F.      We go to superlists/urls.py and add a line so that urls from accounts are recognized.

G.      Unit test passes.

H.      Mocks are a way of testing an application's interaction with outside API's that avoid
        the necessity of actually performing actions with the API's. In our case, we want to
        test that our application properly interacts with outside email providers. But we don't
        actually want to send emails through these providers while doing our testing.

I.      We add a definition for email to our accounts/views.py function. We also add a commented-out
        draft of possible code.

J.      We go back to test_views.py and, in our class, we add a method test_sends_mail_to_address_from_post.
        In the first line, we write self.send_mail_called = False. And then we add another method within
        this method to fake sending an email. In the beginning of that method, we have self.send_mail_called = True,
        and we make the various email components attributes of the test class instance. Then, outside of this
        inner method, we perform our test action: we post to /accounts/send_login_email and
        the email is a fake email account. We then run our assertions, first that send_email was actually called,
        and that the various parts of the email are recognized as identical to the equivalent attributes of the
        test instance.

K.      Unit tests fail because send_mail was not called.

L.      We get rid of our hypothetical code in send_login_email in accounts/views and
        replace it with a simple call to send_mail and a redirect.

M.      Unit test fails because none of the keyword arguments required by our fake send_email
        function have been supplied.

N.      We add the names of the kwargs as strings to our send_mail function.

O.      Unit tests fail because 'subject' != 'Your login link for Superlists'

P.      We change 'subject' to the required subject.

Q.      Unit tests fail because 'from_email' != 'noreplay@superlists'

R.      We change 'from_email' to the required source email.

S.      Unit tests fail because 'to_email' != 'edith@example.com'

T.      We add a new email variable and make it equal to request.POST['email'].
        We then replace 'to_email' with the email variable.

U.      Unit tests pass.

V.      Now, the mock we did was handwritten. But we are reinventing the wheel (twice, because Django does
        email mocking anyway). We can rely on the Python unittest.mock library.

W.      We completely rewrite the last unit test to make use of the capabilities of the mock library.

X.      Unit tests pass, just as before.

Y.      We are suspicious that the test passes after such a drastic change. So we deliberately break it.
        We have it check for the wrong to address, and we add a debug print to our view to have better information
        about what happens.

Z.      The final unit test fails as expected, because the email address it was checking for did not appear
        in the view. Also, we see that when an earlier test was run, the type of send_mail was function.
        But in the final test, the type was unittest.mock.MagicMock. So we can see this in action.

AA.     We remove the debug print and fix our code.

AB.     Unit tests pass as expected.

AC.     Functional tests fail because the "check your email" screen is not appearing.

AD.     We go to lists/templates/base.html, and change the POST action from a placeholder to
        a call to the url named send_login_email.

AE.     Functional tests failed for the same reason.

AF.     We add a unit test test_adds_success_message.

AG.     Unit tests fail because response.context['messages'] contains no items.

AH.     We add code to our views that uses django.contrib.messages to define a successful condition.

AI.     Unit tests pass.

AJ.     Functional tests failing in the same place as before.

AK.     Added a place for our success/failure messages to show up in the base template.

AL.     Functional tests failing because 'Use this link to log in' was not found in the body of the email.

AM.     As a cheat, we add the line directly to our view.

AN.     Functional tests failing because there is no url in the body of the email.

AO.     We build a new test class LoginViewTest that contains the method test_redirects_to_home_page.
        It cheats, because it feeds a hardwired url token directly via a get.

AP.     Unit test fails because the response code was 404. (There was no redirect.)

AQ.     We add a login url to the accounts/urls.py

AR.     We add a new method to views: login. It simply returns a redirect to home.

AS.     Unit tests pass.

AT.     Now we need to get an actual unique token into the body of the email. We begin by writing two
        unit tests: test_creates_token_associated_with_email and test_sends_link_to_login_using_token_uid

AU.     As expected, these tests fail. Specifically, NoneType object has no attribute 'email', and
        NoneType object has no attribute 'uid'.

AV.     We change our function send_login_email in accounts/views.py to include a new variable called token.
        This is an instance of our Token class in accounts.models, and defines the email argument as being equal
        to the defined email variable.

AW.     Unit tests fails because the generated token does not appear in the body of our email.

AX.     We add code to the same function. We define a variable url using
        request.build_absolute_url. This will contain the text 'login?token=' plus a string representation
        of the uid attribute of our token object. We define another variable message_body including our
        message and the url variable. And then we alter the send_mail so that it passes message_body as
        the body of the message.

AY.     Now we need to add code for authentication. Remember that each "if" requires a new test. And
        each try/except requires a new test. So it looks like we have three new unit tests. We add
        a new file to accounts/tests called test_authentication.py

AZ.     We create a new file accounts/authentication.py and add placeholder code.

BA.     Unit tests fail because User matching query does not exist, and because None != <User: User object>

BB.     We add code to the authenticate method in class PasswordlessAuthenticationBackend in the accounts/authentication.py
        file that assigns the generated uid to the variable token and returns User.objects.get(email=token.email)

BC.     Unit tests fail. In the process of fixing one test, we broke another.

BD.     We change the authenticate method by adding a try-except pair. It will return
        the token.email only if the Token exists. If not, it returns None.

BE.     Unit tests fail, with only one error: in the the third test. User matching query does not exist.

BF.     We add and additional except clause that returns and email address if User.DoesNotExist

BG.     Unit tests pass.

BH.     Next we need code that finds a user when one logs in or reports that that user is not in the
        database. We write some tests first.

BI.     Unit tests fail because PasswordlessAuthenticationBackend has no attribute get_user.

BJ.     We make the get_user method that just passes.

BK.     Now the test fails because None != <User: User object>

BL.     So we return User.objects.first()

BM.     Now the test fails because the class User.object is not an instance of a User.object.

BN.     We call get with the email as an argument.

BO.     Now the test is failing because, instead of returning None, the query raises an
        error if the user is not found.

BP.     So we place the code in a try except block. We try to return the email. But
        if it raises a DoesNotExist error, it returns None.

BQ.     Unit tests pass.

BR.     Now we need to use the backend in our login view. We go to settings and add the variable
        AUTHENTICATION_BACKENDS which is assigned to our authentication class.

BS.     We can use mocks for a different purpose now. Previously, we used mocks to prevent
        unwanted side-effects (sending real email messages). Now, we can also use mocks to
        reduce code duplication in the tests.

BT.     We write a new test: test_calls_authenticate_with_uid_from_get_request(self, mock_auth).
        This we decorate with @patch('accounts.views.auth'). We test that the mocked mock_auth.authenticate.call_args
        are the ones we want.

BU.     Unit tests fail because we are trying to mock out something that doesn't exist: accounts.views.auth

BV.     In the accounts/views.py, we add an import to django.contrib.auth

BW.     Now the unit tests fail because the auth function is not taking any arguments. (We haven't used the
        auth function yet.)

BX.     We add a line to our login function. It uses auth.authenticate, but deliberately takes the wrong
        argument.

BY.     And, of course, the unit tests fails because the argument we supplied does not match what the test
        is seeking.

BZ.     So we return to the views and change the argument to this: uid=request.GET.get('token').

CA.     Unit tests pass.

CB.     Now we need to check that if the auth function returns a user, it gets passed to auth.login.
        And this test also uses a patch of the same module.

CC.     Unit tests fails because its returning None instead of the sought return values.

CD.     We add a line to the login view. auth.login('ack!').

CE.     Of course, the unit test fails, because 'ack!' is not what it is looking for.

CF.     We replace the wonky argument with (request, user)

CG.     Unit tests unexpectedly fail: AttributeError: 'AnonymouseUser' object has no attribute '_meta'. This
        is because all users are sent through auth.login. And this causes problems with for our original
        redirect test, which is not currently mocked out.

CH.     We now have a third patch within the Class. It is time to refactor to just one patch for the whole class.

CI.     And we have also written a test_does_not_login_if_user_is_not_authenticated.

CJ.     Unit tests fail, because there is a login, even with the user unauthenticated.

CK.     We change the view so that it logs in only if the user is authenticated.

CL.     Unit tests passed.

CM.     Now we go to our base.html and make sure the navbar shows differently for logged-in
        users and the rest.

CN.     Our functional tests fail because selenium cannot find the element Log out.

CO.     This is because Django's auth framework expects the user model to have a last_login field.

CP.     We write a unit test that reproduces the error in accounts/tests/test_models.py
        In the class UserModelTest, we write the method test_no_problem_with_auth_login

CQ.     As expected, the unit tests fail, because last_login is not one of our fields.

CR.     We go to accounts/models.py and fix the problem. We add a line that disconnects
        the updating of the last login.

CS.     Unit tests pass.

CT.     Functional tests pass.

CU.     We start up the server. In the book, this produced an error. It did not for me.

CV.     In the book, to deal with the error, they re-add the email configuration to settings.py

CW.     And then they add the email password in the shell with export. I did both of these.
        Either way, the server runs fine.

CX.     COMMIT 48: "Custom passwordless auth backend + custom user model"

CY.     Next, we need to test the logout link. We add some extra narrative and test to our functional test.

CZ.     Functional test fails because selenium is unable to locate an element with the name "email".
        This is because the logout button does not yet work.

DA.     We go to accounts/urls.py and add a logout url, making use of Django's logout facilities.

DB.     And we go to lists/templates/base.html and change href for logout so that it references the
        url we have created for this purpose.

DC.     Functional test passes.

DD.     The entire test suite passes.

DE.     COMMIT 49: Added valid logout to user auth; user auth complete.

CHAPTER 20: TEXT FIXTURES AND A DECORATOR FOR EXPLICIT WAITS.

A.      The next step in making our site is to allow users to actually save and interact with lists they've created. And for
        this, we need another functional test. However, we do not need to have the test log a user in each time it is testing
        something. This is very time consuming. We want to test only the things that need to be tested.

B.      We can skip the login process by pre-creating a session. This is similar to the very common process of saving
        cookies to avoid time-consuming replication of work. So we will add a functional test document called
        test_my_lists.py. It contains the class MyListsTest with the method create_pre_authenticated_session.

C.      To check that it works, we want to reuse some of the code we just wrote. We will write two functions
        wait_to_be_logged_in and wait_to_be_logged_out. These will go in functional_tests/base.py so that
        they can be used by all the functional test files.

D.      We use these functions in test_login.py

E.      We rerun the login functional test to make sure we haven't broken anything. Sure enough, it does.

F.      We go to test_my_lists and create a new test method: test_logged_in_users_lists_are_saved_as_my_lists

G.      New functional tests pass.

H.      COMMIT 50: "test_my_lists: precreate sessions, move login checks into base"

I.      Now we will create a decorator to handle wait tasks. We take our first stab at this in a new
        function called wait in functional_tests/base.py. And we decorate our other waiting fucntions
        with wait.

J.      The functional test fails because our decorator function is not right. We are converting our
        function to a new function. But the original function takes arguments, and our new function takes
        none.

K.      So we add *args and **kwargs to our modified function.

L.      Funtional test passes.

M.      We returned a new wait_for funtion. Very simple.

CHAPTER 21: SERVER-SIDE DEBUGGING

A.      Now we will see how things work on the staging server. We deploy to the staging server.

B.      We go to the server, restart the daemon and gunicorn.

C.      The functional tests, run against the staging server, crash and burn. 6 are errors and 1 failure.
        The problem is that, for some reason, the tests are not able to login on the server.

D.      We make sure that we have the right logging settings in the superlists/settings.py file.

E.      We restart gunicorn, and rerun the functional tests against the server. We haven't changed
        anything, so we get the same results.

F.      Next, we inspect Django's server logs by entering this on the server shell:
        sudo journalctl -f -u gunicorn-superlists-staging.DOMAIN-NAME.EXTENSION

G.      It turns out that Gmail is refusing to send our emails. This is because we haven't told the server
        what our password is.

H.      We add our password to the server .env file. We restart everything and load up the server logs.

I.      We run the functional tests again. Now they are failing. Unable to locate element: Log out
        The test is apparently getting farther, but it can't check the email in the mail.outbox.
        We need to change our functional test so that it is able to test real emails via POP3.

J.      We make a slight change to setUp in functional_tests/base.py: the staging_server variable is
        changed to self.staging_server.

K.      Then we build a helper function that can retrieve real email from a real POP3 email server in
        the test_login.py.

NOTE:   It is not enough to use source [filename] to load the filenames into the local environment.
        First, we must use the command set -o allexport. If we wish to turn off this feature,
        we type set +o allexport.

NOTE2:  When using the yahoo mail, the password you send should be an app password, not your
        account password. Currently, this is stored in the .env file. To access this in the
        yahoo account, go to your your account picture, click on account, and navigate to
        security. Then navigate to app passwords.

L.      The latest functional test addition passes.

M.      Running the full functional test suite was a disaster. In the book there was only one test that
        did not work. But here, all of my tests are failing except the one I just created and tested.
        Most of the tests are failing because the attribute get_item_input_box is not recognized.
        This is inherited from FunctionalTest, which inherits from LiveServerTestCase.
        The test files affected are
            test_layout_and_styling
            test_list_item_validation
            test_simple_list_creation

        The expected error was in the test_my_lists.MyListsTest: Unable to locate element Log out.
        This is because our utility create_preauthenticated_session works only on the local database,
        not against the server..
        

N.      We go into the Django management command to create sessions on the server. We create the directory
        functional_tests/management/commands. And we create an __init__.py file in both the management
        directory and the commands directory. In the commands directory we create a new file create_session.py
        and fill it with the code necessary to run a Django command to create a session.  It contains a class
        Command with two methods: add_arguments and handle. Outside of this is a function create_pre_authenticated_session.

O.      An attempt to call the function create_session from the command line fails because we have not yet registered
        the functional_tests app in settings.

P.      We add functional_tests to settings.

Q.      Again an attempt to call the function fails because the table accounts_user was not found. We need to migrate.

R.      An attempt to migrate failed because some tables already exist.

S.      We delete the db.sqlite3 file and run migrate again.

T.      Migrated successfully.

U.      Running the create_session file from the command line returned a code string, as expected.

V.      We fix test_my_lists so that it runs the local function on the local server and runs the
        management command when we're on the staging server.

W.      And we tweak base.py so that it gathers more info.

X.      We add the file functional_tests/server_tools.py which allows us to run Fabric code right from our app
        without using the command line.

Y.      First, we check to see that we didn't break anything. We run the test_my_lists test locally. It passes.

Z.      COMMIT #51: "Working toward deployment on the staging server: adjusted test database management
        and added a file for using Fabric."

            





















        


