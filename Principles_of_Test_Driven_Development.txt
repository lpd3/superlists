PRINCIPLES OF TEST DRIVEN DEVELOPMENT (TDD)

1.	Obey the testing goat!

The basic procedure is:
a.	Write a test
b.	Run it to assure that it fails.
c.	Write the simplest code that makes the test pass.

2.	Design your functional test by creating a “user story”: a script of the user’s
	experience using the application.

3.	Expected failure: A test that fails in a way that we predict ahead of time. In TDD,
	this is a much-encountered, and hoped-for situation.

4.	Unit test: A “behind the scenes test”. This is a test of bit of code functionality.
	It is sharply differentiated from the “functional test”, a test of the application as
	a whole from the user perspective.

5.	TDD steps, 2nd version
a.	Write a Functional Test based on a user narrative, and make sure it fails.
b.	Consider how to make the Functional Test pass in the simplest way.
c.	Write a unit test to test the basic function of the proposed code change. Get it
	to fail.
d.	Write code until you can get the unit test to pass.
e.	Re-run the Functional Test. If it fails, go back to step b.
	If not, flesh out the Functional Test a little more, get it to fail, and go back to b.

6.      When making a git commit, always review it first.

7.      It may seem ludicrous to test miniscule changes in code. However, it is difficulty to
        determine when a project is becoming complex. Testing all along allows the project
        to be rigrously tested when it becomes complex.

8.      A rule about functional tests: DON'T TEST CONSTANTS.

9.      Unit tests are really about testing logic, flow control and configuration.

10.     Refactoring: Improving the code WITHOUT CHANGING ITS FUNCTIONALITY

11.     You cannot refactor without tests.

12.     When refactoring, work on either the code or the tests, but not both at once.

13.     We have now seen all the main parts of the TDD process. These include:
        A. Functional Tests
        B. Unit Tests
        C. The unit-test/code cycle
        D. Refactoring

14.     And here is the complete TDD process:
        A. Write a test. Go to B.
        B. Run the test. If it passes, go to C. If not, go to D.
        C. Determine if there is a need for refactoring. If so, go to D. If not, go to A.
        D. Write minimal code. Go to B.

15.     Employing Functional Tests and Unit Tests, we have a double loop TDD process:
        A. Write a functional test. Go to B.
        B. Run the functional test. If it passes, Go to C. If not, go to D.
        C. Determine whether the application needs refactoring. If so, go to D. If not, go to A.
        D. Write a unit test. Go to E.
        E. Run the unit test. If it passes, go to F. If not, go to G.
        F. Determine whether the application needs refactoring. If so, go to G. If not, go to B.
        G. Write minimal code. Go to E.

16.     When a functional test fails with an unexpected failure, there are several things we can do
        to debug it. These include (but are not limited to)
        A. Add print statements, to show, for example what the current page text is.
        B. Improve the error message to show more info about the current state.
        C. Manually vist the site yourself.
        D. Use time.sleep to pause the test during execution.

17.     The basic TDD loop is sometimes called "Red, Green, Refactor". Write a test. It fails (RED). Write some
        simple code that gets the test passes (GREEN). Change the code to make it better (REFACTOR). One way
        to refactor is to remove duplicate code. A better, less nebulous, name for the last step would be
        Triangulate. After the Green, we write a new test that does not allow our simple (perhaps cheating)
        solution to work. Then we go back to the loop.

18.     We check for "bad code smell." This occurs when the code is overly complex or repetitive. The
        process of TDD, by using incremental steps, often requires us to use nearly identical code in
        more than one place. We tolerate this duplication only once (allowing two pieces of code to be nearly
        identical. Once we get to a third temptation to repeat the code, we stop and refactor.

19.     For now, we deal with Functional Tests and Unit Tests. Our test of database functioning is accomplished
        through the Unit Tests. However, in reality, tests which assess the behavior of objects outside the
        code, such as databases, are properly called Integrated Tests. We will ignore this distinction for now
        and come back to it later.

20.     Each test method in the unit tests should test only one thing.

21.     A helpful, but not mandatory, way to organize a unit test method is as follows:
        the set-up section (followed by a blank line)
        a line in the middle that calls what is being tested (followed by a blank line)
        the test: the assertion or assertions made about the results of calling the code.

22.     Regression: when new code breaks some aspect of the application which used to work.

23.     Unexpected failure: When a test fails in a way we weren't expecting. This either means
        that we've made a mistake in our tests, or that the tests have helped us to find a
        regression, and we need to fix something in our code.

24.     Test isolation. We need to make sure that our tests leave behind nothing that will
        influence the next test session, or the running of the probject. Therefore, tests
        should clean up after themselves. In our pet project, the unit tests automatically
        self-clean. The functional tests do not.
